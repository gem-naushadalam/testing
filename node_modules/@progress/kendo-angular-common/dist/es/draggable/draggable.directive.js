/**-----------------------------------------------------------------------------------------
* Copyright © 2020 Progress Software Corporation. All rights reserved.
* Licensed under commercial license. See LICENSE.md in the project root for more information
*-------------------------------------------------------------------------------------------*/
import * as tslib_1 from "tslib";
import { EventEmitter, ElementRef, Directive, Output, NgZone, Input } from '@angular/core';
import { isDocumentAvailable, isChanged } from '../utils';
import Draggable from '@telerik/kendo-draggable';
import * as ɵngcc0 from '@angular/core';
var DraggableDirective = /** @class */ (function () {
    function DraggableDirective(element, ngZone) {
        this.element = element;
        this.ngZone = ngZone;
        this.enableDrag = true;
        this.kendoPress = new EventEmitter();
        this.kendoDrag = new EventEmitter();
        this.kendoRelease = new EventEmitter();
    }
    DraggableDirective.prototype.ngOnInit = function () {
        this.toggleDraggable();
    };
    DraggableDirective.prototype.ngOnChanges = function (changes) {
        if (isChanged('enableDrag', changes)) {
            this.toggleDraggable();
        }
    };
    DraggableDirective.prototype.ngOnDestroy = function () {
        this.destroyDraggable();
    };
    DraggableDirective.prototype.toggleDraggable = function () {
        var _this = this;
        if (isDocumentAvailable()) {
            this.destroyDraggable();
            if (this.enableDrag) {
                this.draggable = new Draggable({
                    drag: function (e) { return _this.kendoDrag.next(e); },
                    press: function (e) { return _this.kendoPress.next(e); },
                    release: function (e) { return _this.kendoRelease.next(e); }
                });
                this.ngZone.runOutsideAngular(function () { return _this.draggable.bindTo(_this.element.nativeElement); });
            }
        }
    };
    DraggableDirective.prototype.destroyDraggable = function () {
        if (this.draggable) {
            this.draggable.destroy();
            this.draggable = null;
        }
    };
    tslib_1.__decorate([
        Input(),
        tslib_1.__metadata("design:type", Boolean)
    ], DraggableDirective.prototype, "enableDrag", void 0);
    tslib_1.__decorate([
        Output(),
        tslib_1.__metadata("design:type", EventEmitter)
    ], DraggableDirective.prototype, "kendoPress", void 0);
    tslib_1.__decorate([
        Output(),
        tslib_1.__metadata("design:type", EventEmitter)
    ], DraggableDirective.prototype, "kendoDrag", void 0);
    tslib_1.__decorate([
        Output(),
        tslib_1.__metadata("design:type", EventEmitter)
    ], DraggableDirective.prototype, "kendoRelease", void 0);
    DraggableDirective = tslib_1.__decorate([ tslib_1.__metadata("design:paramtypes", [ElementRef, NgZone])
    ], DraggableDirective);
DraggableDirective.ɵfac = function DraggableDirective_Factory(t) { return new (t || DraggableDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
DraggableDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: DraggableDirective, selectors: [["", "kendoDraggable", ""]], inputs: { enableDrag: "enableDrag" }, outputs: { kendoPress: "kendoPress", kendoDrag: "kendoDrag", kendoRelease: "kendoRelease" }, features: [ɵngcc0.ɵɵNgOnChangesFeature] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(DraggableDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoDraggable]'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }]; }, { enableDrag: [{
            type: Input
        }], kendoPress: [{
            type: Output
        }], kendoDrag: [{
            type: Output
        }], kendoRelease: [{
            type: Output
        }] }); })();
    return DraggableDirective;
}());
export { DraggableDirective };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZHJhZ2dhYmxlLmRpcmVjdGl2ZS5qcyIsInNvdXJjZXMiOlsiZHJhZ2dhYmxlLmRpcmVjdGl2ZS5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FJTztBQUNQOzs7Ozs7Ozs7Ozs7Ozs7O29CQUEyQjtBQUMzQjtBQUNBO0FBQ0EiLCJzb3VyY2VzQ29udGVudCI6WyIvKiotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuKiBDb3B5cmlnaHQgwqkgMjAyMCBQcm9ncmVzcyBTb2Z0d2FyZSBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiogTGljZW5zZWQgdW5kZXIgY29tbWVyY2lhbCBsaWNlbnNlLiBTZWUgTElDRU5TRS5tZCBpbiB0aGUgcHJvamVjdCByb290IGZvciBtb3JlIGluZm9ybWF0aW9uXG4qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5pbXBvcnQgKiBhcyB0c2xpYl8xIGZyb20gXCJ0c2xpYlwiO1xuaW1wb3J0IHsgRXZlbnRFbWl0dGVyLCBFbGVtZW50UmVmLCBEaXJlY3RpdmUsIE91dHB1dCwgTmdab25lLCBJbnB1dCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgaXNEb2N1bWVudEF2YWlsYWJsZSwgaXNDaGFuZ2VkIH0gZnJvbSAnLi4vdXRpbHMnO1xuaW1wb3J0IERyYWdnYWJsZSBmcm9tICdAdGVsZXJpay9rZW5kby1kcmFnZ2FibGUnO1xudmFyIERyYWdnYWJsZURpcmVjdGl2ZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBEcmFnZ2FibGVEaXJlY3RpdmUoZWxlbWVudCwgbmdab25lKSB7XG4gICAgICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICAgIHRoaXMubmdab25lID0gbmdab25lO1xuICAgICAgICB0aGlzLmVuYWJsZURyYWcgPSB0cnVlO1xuICAgICAgICB0aGlzLmtlbmRvUHJlc3MgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMua2VuZG9EcmFnID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLmtlbmRvUmVsZWFzZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICB9XG4gICAgRHJhZ2dhYmxlRGlyZWN0aXZlLnByb3RvdHlwZS5uZ09uSW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy50b2dnbGVEcmFnZ2FibGUoKTtcbiAgICB9O1xuICAgIERyYWdnYWJsZURpcmVjdGl2ZS5wcm90b3R5cGUubmdPbkNoYW5nZXMgPSBmdW5jdGlvbiAoY2hhbmdlcykge1xuICAgICAgICBpZiAoaXNDaGFuZ2VkKCdlbmFibGVEcmFnJywgY2hhbmdlcykpIHtcbiAgICAgICAgICAgIHRoaXMudG9nZ2xlRHJhZ2dhYmxlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIERyYWdnYWJsZURpcmVjdGl2ZS5wcm90b3R5cGUubmdPbkRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZGVzdHJveURyYWdnYWJsZSgpO1xuICAgIH07XG4gICAgRHJhZ2dhYmxlRGlyZWN0aXZlLnByb3RvdHlwZS50b2dnbGVEcmFnZ2FibGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmIChpc0RvY3VtZW50QXZhaWxhYmxlKCkpIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdHJveURyYWdnYWJsZSgpO1xuICAgICAgICAgICAgaWYgKHRoaXMuZW5hYmxlRHJhZykge1xuICAgICAgICAgICAgICAgIHRoaXMuZHJhZ2dhYmxlID0gbmV3IERyYWdnYWJsZSh7XG4gICAgICAgICAgICAgICAgICAgIGRyYWc6IGZ1bmN0aW9uIChlKSB7IHJldHVybiBfdGhpcy5rZW5kb0RyYWcubmV4dChlKTsgfSxcbiAgICAgICAgICAgICAgICAgICAgcHJlc3M6IGZ1bmN0aW9uIChlKSB7IHJldHVybiBfdGhpcy5rZW5kb1ByZXNzLm5leHQoZSk7IH0sXG4gICAgICAgICAgICAgICAgICAgIHJlbGVhc2U6IGZ1bmN0aW9uIChlKSB7IHJldHVybiBfdGhpcy5rZW5kb1JlbGVhc2UubmV4dChlKTsgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHRoaXMubmdab25lLnJ1bk91dHNpZGVBbmd1bGFyKGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLmRyYWdnYWJsZS5iaW5kVG8oX3RoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50KTsgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIERyYWdnYWJsZURpcmVjdGl2ZS5wcm90b3R5cGUuZGVzdHJveURyYWdnYWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuZHJhZ2dhYmxlKSB7XG4gICAgICAgICAgICB0aGlzLmRyYWdnYWJsZS5kZXN0cm95KCk7XG4gICAgICAgICAgICB0aGlzLmRyYWdnYWJsZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHRzbGliXzEuX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIHRzbGliXzEuX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG4gICAgXSwgRHJhZ2dhYmxlRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJlbmFibGVEcmFnXCIsIHZvaWQgMCk7XG4gICAgdHNsaWJfMS5fX2RlY29yYXRlKFtcbiAgICAgICAgT3V0cHV0KCksXG4gICAgICAgIHRzbGliXzEuX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEV2ZW50RW1pdHRlcilcbiAgICBdLCBEcmFnZ2FibGVEaXJlY3RpdmUucHJvdG90eXBlLCBcImtlbmRvUHJlc3NcIiwgdm9pZCAwKTtcbiAgICB0c2xpYl8xLl9fZGVjb3JhdGUoW1xuICAgICAgICBPdXRwdXQoKSxcbiAgICAgICAgdHNsaWJfMS5fX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRXZlbnRFbWl0dGVyKVxuICAgIF0sIERyYWdnYWJsZURpcmVjdGl2ZS5wcm90b3R5cGUsIFwia2VuZG9EcmFnXCIsIHZvaWQgMCk7XG4gICAgdHNsaWJfMS5fX2RlY29yYXRlKFtcbiAgICAgICAgT3V0cHV0KCksXG4gICAgICAgIHRzbGliXzEuX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEV2ZW50RW1pdHRlcilcbiAgICBdLCBEcmFnZ2FibGVEaXJlY3RpdmUucHJvdG90eXBlLCBcImtlbmRvUmVsZWFzZVwiLCB2b2lkIDApO1xuICAgIERyYWdnYWJsZURpcmVjdGl2ZSA9IHRzbGliXzEuX19kZWNvcmF0ZShbXG4gICAgICAgIERpcmVjdGl2ZSh7XG4gICAgICAgICAgICBzZWxlY3RvcjogJ1trZW5kb0RyYWdnYWJsZV0nXG4gICAgICAgIH0pLFxuICAgICAgICB0c2xpYl8xLl9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbRWxlbWVudFJlZiwgTmdab25lXSlcbiAgICBdLCBEcmFnZ2FibGVEaXJlY3RpdmUpO1xuICAgIHJldHVybiBEcmFnZ2FibGVEaXJlY3RpdmU7XG59KCkpO1xuZXhwb3J0IHsgRHJhZ2dhYmxlRGlyZWN0aXZlIH07XG4iXX0=