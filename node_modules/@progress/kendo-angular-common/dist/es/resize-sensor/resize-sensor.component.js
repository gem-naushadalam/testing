/**-----------------------------------------------------------------------------------------
* Copyright © 2020 Progress Software Corporation. All rights reserved.
* Licensed under commercial license. See LICENSE.md in the project root for more information
*-------------------------------------------------------------------------------------------*/
import * as tslib_1 from "tslib";
import { Component, EventEmitter, Input, Output, ElementRef, NgZone } from '@angular/core';
import { auditTime } from 'rxjs/operators';
import { ResizeCompatService } from './compat.service';
import { ResizeObserverService } from './observer.service';
import { ResizeBatchService } from './resize-batch.service';
/**
 * Emit up to 10 resize events per second by default.
 * Chosen as a compromise between responsiveness and performance.
 */
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from './resize-batch.service';
var DEFAULT_RATE_LIMIT = 10;
/**
 * Resize Sensor Component
 *
 * Triggers a "resize" event whenever the parent DOM element size changes.
 */
var ResizeSensorComponent = /** @class */ (function () {
    function ResizeSensorComponent(resizeBatchService, element, ngZone) {
        var _this = this;
        /**
         * The maximum number of resize events to emit per second.
         *
         * Defaults to 10.
         */
        this.rateLimit = DEFAULT_RATE_LIMIT;
        /**
         * Fires when the parent DOM element has been resized.
         */
        this.resize = new EventEmitter();
        var serviceType = ResizeObserverService.supported() ? ResizeObserverService : ResizeCompatService;
        this.resizeService = new serviceType(resizeBatchService, element, ngZone);
        var throttleTime = 1000 / (this.rateLimit || DEFAULT_RATE_LIMIT);
        this.subscription = this.resizeService.resize
            .pipe(auditTime(throttleTime))
            .subscribe(function () {
            if (!_this.resizeService.acceptedSize) {
                _this.resize.emit();
            }
        });
    }
    ResizeSensorComponent.prototype.ngAfterViewChecked = function () {
        this.resizeService.checkChanges();
    };
    ResizeSensorComponent.prototype.ngOnDestroy = function () {
        this.subscription.unsubscribe();
        this.resizeService.destroy();
    };
    ResizeSensorComponent.prototype.acceptSize = function (size) {
        this.resizeService.acceptSize(size);
    };
    tslib_1.__decorate([
        Input(),
        tslib_1.__metadata("design:type", Number)
    ], ResizeSensorComponent.prototype, "rateLimit", void 0);
    tslib_1.__decorate([
        Output(),
        tslib_1.__metadata("design:type", EventEmitter)
    ], ResizeSensorComponent.prototype, "resize", void 0);
    ResizeSensorComponent = tslib_1.__decorate([ tslib_1.__metadata("design:paramtypes", [ResizeBatchService, ElementRef, NgZone])
    ], ResizeSensorComponent);
ResizeSensorComponent.ɵfac = function ResizeSensorComponent_Factory(t) { return new (t || ResizeSensorComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc1.ResizeBatchService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
ResizeSensorComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ResizeSensorComponent, selectors: [["kendo-resize-sensor"]], inputs: { rateLimit: "rateLimit" }, outputs: { resize: "resize" }, decls: 0, vars: 0, template: function ResizeSensorComponent_Template(rf, ctx) { }, encapsulation: 2 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ResizeSensorComponent, [{
        type: Component,
        args: [{
                selector: 'kendo-resize-sensor',
                template: ''
            }]
    }], function () { return [{ type: ɵngcc1.ResizeBatchService }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }]; }, { rateLimit: [{
            type: Input
        }], resize: [{
            type: Output
        }] }); })();
    return ResizeSensorComponent;
}());
export { ResizeSensorComponent };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicmVzaXplLXNlbnNvci5jb21wb25lbnQuanMiLCJzb3VyY2VzIjpbInJlc2l6ZS1zZW5zb3IuY29tcG9uZW50LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUtPO0FBQ1A7Ozs7Ozs7Ozs7Ozs7b0JBQThCO0FBQzlCO0FBQ0E7QUFDQSIsInNvdXJjZXNDb250ZW50IjpbIi8qKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4qIENvcHlyaWdodCDCqSAyMDIwIFByb2dyZXNzIFNvZnR3YXJlIENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuKiBMaWNlbnNlZCB1bmRlciBjb21tZXJjaWFsIGxpY2Vuc2UuIFNlZSBMSUNFTlNFLm1kIGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIG1vcmUgaW5mb3JtYXRpb25cbiotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbmltcG9ydCAqIGFzIHRzbGliXzEgZnJvbSBcInRzbGliXCI7XG5pbXBvcnQgeyBDb21wb25lbnQsIEV2ZW50RW1pdHRlciwgSW5wdXQsIE91dHB1dCwgRWxlbWVudFJlZiwgTmdab25lIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBhdWRpdFRpbWUgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQgeyBSZXNpemVDb21wYXRTZXJ2aWNlIH0gZnJvbSAnLi9jb21wYXQuc2VydmljZSc7XG5pbXBvcnQgeyBSZXNpemVPYnNlcnZlclNlcnZpY2UgfSBmcm9tICcuL29ic2VydmVyLnNlcnZpY2UnO1xuaW1wb3J0IHsgUmVzaXplQmF0Y2hTZXJ2aWNlIH0gZnJvbSAnLi9yZXNpemUtYmF0Y2guc2VydmljZSc7XG4vKipcbiAqIEVtaXQgdXAgdG8gMTAgcmVzaXplIGV2ZW50cyBwZXIgc2Vjb25kIGJ5IGRlZmF1bHQuXG4gKiBDaG9zZW4gYXMgYSBjb21wcm9taXNlIGJldHdlZW4gcmVzcG9uc2l2ZW5lc3MgYW5kIHBlcmZvcm1hbmNlLlxuICovXG52YXIgREVGQVVMVF9SQVRFX0xJTUlUID0gMTA7XG4vKipcbiAqIFJlc2l6ZSBTZW5zb3IgQ29tcG9uZW50XG4gKlxuICogVHJpZ2dlcnMgYSBcInJlc2l6ZVwiIGV2ZW50IHdoZW5ldmVyIHRoZSBwYXJlbnQgRE9NIGVsZW1lbnQgc2l6ZSBjaGFuZ2VzLlxuICovXG52YXIgUmVzaXplU2Vuc29yQ29tcG9uZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFJlc2l6ZVNlbnNvckNvbXBvbmVudChyZXNpemVCYXRjaFNlcnZpY2UsIGVsZW1lbnQsIG5nWm9uZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIG1heGltdW0gbnVtYmVyIG9mIHJlc2l6ZSBldmVudHMgdG8gZW1pdCBwZXIgc2Vjb25kLlxuICAgICAgICAgKlxuICAgICAgICAgKiBEZWZhdWx0cyB0byAxMC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucmF0ZUxpbWl0ID0gREVGQVVMVF9SQVRFX0xJTUlUO1xuICAgICAgICAvKipcbiAgICAgICAgICogRmlyZXMgd2hlbiB0aGUgcGFyZW50IERPTSBlbGVtZW50IGhhcyBiZWVuIHJlc2l6ZWQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnJlc2l6ZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdmFyIHNlcnZpY2VUeXBlID0gUmVzaXplT2JzZXJ2ZXJTZXJ2aWNlLnN1cHBvcnRlZCgpID8gUmVzaXplT2JzZXJ2ZXJTZXJ2aWNlIDogUmVzaXplQ29tcGF0U2VydmljZTtcbiAgICAgICAgdGhpcy5yZXNpemVTZXJ2aWNlID0gbmV3IHNlcnZpY2VUeXBlKHJlc2l6ZUJhdGNoU2VydmljZSwgZWxlbWVudCwgbmdab25lKTtcbiAgICAgICAgdmFyIHRocm90dGxlVGltZSA9IDEwMDAgLyAodGhpcy5yYXRlTGltaXQgfHwgREVGQVVMVF9SQVRFX0xJTUlUKTtcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb24gPSB0aGlzLnJlc2l6ZVNlcnZpY2UucmVzaXplXG4gICAgICAgICAgICAucGlwZShhdWRpdFRpbWUodGhyb3R0bGVUaW1lKSlcbiAgICAgICAgICAgIC5zdWJzY3JpYmUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKCFfdGhpcy5yZXNpemVTZXJ2aWNlLmFjY2VwdGVkU2l6ZSkge1xuICAgICAgICAgICAgICAgIF90aGlzLnJlc2l6ZS5lbWl0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBSZXNpemVTZW5zb3JDb21wb25lbnQucHJvdG90eXBlLm5nQWZ0ZXJWaWV3Q2hlY2tlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5yZXNpemVTZXJ2aWNlLmNoZWNrQ2hhbmdlcygpO1xuICAgIH07XG4gICAgUmVzaXplU2Vuc29yQ29tcG9uZW50LnByb3RvdHlwZS5uZ09uRGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgdGhpcy5yZXNpemVTZXJ2aWNlLmRlc3Ryb3koKTtcbiAgICB9O1xuICAgIFJlc2l6ZVNlbnNvckNvbXBvbmVudC5wcm90b3R5cGUuYWNjZXB0U2l6ZSA9IGZ1bmN0aW9uIChzaXplKSB7XG4gICAgICAgIHRoaXMucmVzaXplU2VydmljZS5hY2NlcHRTaXplKHNpemUpO1xuICAgIH07XG4gICAgdHNsaWJfMS5fX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgdHNsaWJfMS5fX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxuICAgIF0sIFJlc2l6ZVNlbnNvckNvbXBvbmVudC5wcm90b3R5cGUsIFwicmF0ZUxpbWl0XCIsIHZvaWQgMCk7XG4gICAgdHNsaWJfMS5fX2RlY29yYXRlKFtcbiAgICAgICAgT3V0cHV0KCksXG4gICAgICAgIHRzbGliXzEuX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEV2ZW50RW1pdHRlcilcbiAgICBdLCBSZXNpemVTZW5zb3JDb21wb25lbnQucHJvdG90eXBlLCBcInJlc2l6ZVwiLCB2b2lkIDApO1xuICAgIFJlc2l6ZVNlbnNvckNvbXBvbmVudCA9IHRzbGliXzEuX19kZWNvcmF0ZShbXG4gICAgICAgIENvbXBvbmVudCh7XG4gICAgICAgICAgICBzZWxlY3RvcjogJ2tlbmRvLXJlc2l6ZS1zZW5zb3InLFxuICAgICAgICAgICAgdGVtcGxhdGU6ICcnXG4gICAgICAgIH0pLFxuICAgICAgICB0c2xpYl8xLl9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbUmVzaXplQmF0Y2hTZXJ2aWNlLCBFbGVtZW50UmVmLCBOZ1pvbmVdKVxuICAgIF0sIFJlc2l6ZVNlbnNvckNvbXBvbmVudCk7XG4gICAgcmV0dXJuIFJlc2l6ZVNlbnNvckNvbXBvbmVudDtcbn0oKSk7XG5leHBvcnQgeyBSZXNpemVTZW5zb3JDb21wb25lbnQgfTtcbiJdfQ==