/**-----------------------------------------------------------------------------------------
* Copyright © 2020 Progress Software Corporation. All rights reserved.
* Licensed under commercial license. See LICENSE.md in the project root for more information
*-------------------------------------------------------------------------------------------*/
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var core_1 = require("@angular/core");
var rxjs_1 = require("rxjs");
var operators_1 = require("rxjs/operators");
var kendo_angular_common_1 = require("@progress/kendo-angular-common");
var kendo_licensing_1 = require("@progress/kendo-licensing");
var package_metadata_1 = require("../package-metadata");
var kendo_angular_l10n_1 = require("@progress/kendo-angular-l10n");
var item_template_directive_1 = require("./template-directives/item-template.directive");
var util_1 = require("../common/util");
var list_component_1 = require("./list.component");
var util_2 = require("./util");
/**
 * Represents the [Kendo UI Breadcrumb component for Angular]({% slug overview_breadcrumb %}).
 *
 * @example
 * ```ts-no-run
 * _@Component({
 *      selector: 'my-app',
 *      template: `
 *          <kendo-breadcrumb
 *              [items]="items"
 *              (itemClick)="onItemClick($event)">
 *          </kendo-breadcrumb>
 *      `
 * })
 * class AppComponent {
 *      public items: BreadCrumbItem[] = [
 *          { text: 'Home', title: 'Home', icon: 'home' },
 *          { text: 'Kids', title: 'Kids' },
 *          { text: '8y-16y', title: '8y-16y', disabled: true },
 *          { text: 'New collection', title: 'New collection' },
 *          { text: 'Jeans', title: 'Jeans' }
 *      ];
 *
 *      public onItemClick(item: BreadCrumbItem): void {
 *          console.log(item);
 *      }
 * }
 * ```
 */
var ɵngcc0 = require('@angular/core');
var ɵngcc1 = require('@progress/kendo-angular-l10n');
var ɵngcc2 = require('@angular/common');
var ɵngcc3 = require('./list.component');
var ɵngcc4 = require('@progress/kendo-angular-common');

var _c0 = ["resizeSensor"];
var _c1 = ["itemsContainer"];
function BreadCrumbComponent_ol_0_Template(rf, ctx) { if (rf & 1) {
    var _r5 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "ol", 5, 2);
    ɵngcc0.ɵɵlistener("itemClick", function BreadCrumbComponent_ol_0_Template_ol_itemClick_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r5); var ctx_r4 = ɵngcc0.ɵɵnextContext(); return ctx_r4.itemClick.emit($event); });
    ɵngcc0.ɵɵpipe(2, "async");
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("items", ɵngcc0.ɵɵpipeBind1(2, 4, ctx_r0.firstItem$))("itemTemplate", ctx_r0.itemTemplate == null ? null : ctx_r0.itemTemplate.templateRef)("collapseMode", ctx_r0.collapseMode)("separatorIcon", ctx_r0.separatorIcon);
} }
var _c2 = function (a0, a1) { return { "k-flex-wrap": a0, "k-flex-none": a1 }; };
var BreadCrumbComponent = /** @class */ (function () {
    function BreadCrumbComponent(el, cdr, zone, localization) {
        this.el = el;
        this.cdr = cdr;
        this.zone = zone;
        this.localization = localization;
        /**
         * Fires when a Breadcrumb item is clicked. The event will not be fired by disabled items and the last item.
         */
        this.itemClick = new core_1.EventEmitter();
        this.hostClasses = true;
        this._items = [];
        this._collapseMode = 'auto';
        this.updateItems = new rxjs_1.ReplaySubject();
        this.afterViewInit = new rxjs_1.Subject();
        this.subscriptions = new rxjs_1.Subscription();
        this.direction = 'ltr';
        kendo_licensing_1.validatePackage(package_metadata_1.packageMetadata);
        var updateItems$ = this.updateItems.asObservable().pipe(operators_1.startWith([]));
        this.direction = localization.rtl ? 'rtl' : 'ltr';
        this.itemsData$ = updateItems$.pipe(operators_1.map(function (items) { return items.filter(Boolean); }), operators_1.map(function (items) {
            return items.map(function (item, index, collection) { return ({
                context: {
                    collapsed: false,
                    isLast: index === collection.length - 1,
                    isFirst: index === 0
                },
                data: item
            }); });
        }), operators_1.share());
        this.firstItem$ = updateItems$.pipe(operators_1.map(function (items) {
            if (items.length > 0) {
                return [
                    {
                        context: {
                            collapsed: false,
                            isLast: items.length === 1,
                            isFirst: true
                        },
                        data: items[0]
                    }
                ];
            }
            return [];
        }), operators_1.share());
    }
    Object.defineProperty(BreadCrumbComponent.prototype, "items", {
        get: function () {
            return this._items;
        },
        /**
         * The collection of items that will be rendered in the Breadcrumb.
         */
        set: function (items) {
            this._items = items || [];
            this.updateItems.next(this._items);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BreadCrumbComponent.prototype, "collapseMode", {
        get: function () {
            return this._collapseMode;
        },
        /**
         * Specifies the collapse mode of the Breadcrumb ([see example]({% slug collapse_modes_breadcrumb %})).
         *
         * The possible values are:
         * - `auto` (default)&mdash;items are automatically collapsed based on the width of the Breadcrumb.
         * - `wrap`&mdash;items are wrapped on multiple rows.
         * - `none`&mdash;all items are expanded on the same row.
         *
         * For more information and example refer to the [Collapse Modes]({% slug collapse_modes_breadcrumb %}) article.
         */
        set: function (mode) {
            if (core_1.isDevMode() && ['auto', 'wrap', 'none'].indexOf(mode) < 0) {
                throw new Error('Invalid collapse mode. Allowed values are "auto", "wrap" or "none". \nFor more details see https://www.telerik.com/kendo-angular-ui/components/navigation/api/BreadCrumbCollapseMode/');
            }
            this._collapseMode = mode || 'auto';
            this.updateItems.next(this.items);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BreadCrumbComponent.prototype, "wrapMode", {
        get: function () {
            return this.collapseMode === 'wrap';
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BreadCrumbComponent.prototype, "getDir", {
        get: function () {
            return this.direction;
        },
        enumerable: true,
        configurable: true
    });
    BreadCrumbComponent.prototype.ngOnInit = function () {
        var _this = this;
        this.subscriptions.add(this.localization.changes.subscribe(function (_a) {
            var rtl = _a.rtl;
            return (_this.direction = rtl ? 'rtl' : 'ltr');
        }));
    };
    BreadCrumbComponent.prototype.ngAfterViewInit = function () {
        this.attachResizeHandler();
        this.afterViewInit.next();
    };
    BreadCrumbComponent.prototype.ngOnDestroy = function () {
        this.subscriptions.unsubscribe();
    };
    BreadCrumbComponent.prototype.handleResize = function () {
        var autoCollapseCandidates = this.listComponent.renderedItems.toArray().filter(function (ri) { return !ri.item.context.isFirst && !ri.item.context.isLast; }).slice();
        var componentWidth = util_1.outerWidth(this.el.nativeElement);
        var itemsContainerWidth = Math.floor(this.itemsContainers
            .toArray()
            .map(function (el) { return util_1.outerWidth(el.nativeElement); })
            .reduce(function (acc, curr) { return acc + curr; }, 0));
        var nextExpandWidth = (autoCollapseCandidates.slice().reverse().find(util_2.collapsed) || { width: 0 }).width;
        // // shrink
        if (componentWidth <= itemsContainerWidth && autoCollapseCandidates.find(util_2.expanded)) {
            util_2.collapseFirst(autoCollapseCandidates);
            // needed by resize sensor
            this.cdr.detectChanges();
            return this.handleResize();
        }
        // expand
        if (componentWidth > itemsContainerWidth + nextExpandWidth && autoCollapseCandidates.find(util_2.collapsed)) {
            util_2.expandFirst(autoCollapseCandidates.slice().reverse());
            // needed by resize sensor
            this.cdr.detectChanges();
            return this.handleResize();
        }
    };
    BreadCrumbComponent.prototype.shouldResize = function () {
        return kendo_angular_common_1.isDocumentAvailable() && this.collapseMode === 'auto';
    };
    BreadCrumbComponent.prototype.attachResizeHandler = function () {
        var _this = this;
        // resize when:
        // the component is initialized
        // the container is resized
        // items are added/removed
        this.subscriptions.add(rxjs_1.merge(this.resizeSensor.resize, this.itemsData$, this.afterViewInit.asObservable())
            .pipe(operators_1.filter(function () { return _this.shouldResize(); }))
            .subscribe(function () {
            _this.zone.runOutsideAngular(function () {
                return setTimeout(function () {
                    _this.zone.run(function () {
                        if (_this.listComponent) {
                            _this.handleResize();
                            _this.resizeSensor.acceptSize();
                        }
                    });
                });
            });
        }));
    };
    tslib_1.__decorate([
        core_1.Input(),
        tslib_1.__metadata("design:type", Array),
        tslib_1.__metadata("design:paramtypes", [Array])
    ], BreadCrumbComponent.prototype, "items", null);
    tslib_1.__decorate([
        core_1.Input(),
        tslib_1.__metadata("design:type", String)
    ], BreadCrumbComponent.prototype, "separatorIcon", void 0);
    tslib_1.__decorate([
        core_1.Input(),
        tslib_1.__metadata("design:type", String),
        tslib_1.__metadata("design:paramtypes", [String])
    ], BreadCrumbComponent.prototype, "collapseMode", null);
    tslib_1.__decorate([
        core_1.Output(),
        tslib_1.__metadata("design:type", core_1.EventEmitter)
    ], BreadCrumbComponent.prototype, "itemClick", void 0);
    tslib_1.__decorate([
        core_1.ViewChild('resizeSensor', { static: true }),
        tslib_1.__metadata("design:type", kendo_angular_common_1.ResizeSensorComponent)
    ], BreadCrumbComponent.prototype, "resizeSensor", void 0);
    tslib_1.__decorate([
        core_1.ViewChildren('itemsContainer', { read: core_1.ElementRef }),
        tslib_1.__metadata("design:type", core_1.QueryList)
    ], BreadCrumbComponent.prototype, "itemsContainers", void 0);
    tslib_1.__decorate([
        core_1.ViewChild(list_component_1.BreadCrumbListComponent, { static: true }),
        tslib_1.__metadata("design:type", list_component_1.BreadCrumbListComponent)
    ], BreadCrumbComponent.prototype, "listComponent", void 0);
    tslib_1.__decorate([
        core_1.ContentChild(item_template_directive_1.BreadCrumbItemTemplateDirective, { static: true }),
        tslib_1.__metadata("design:type", item_template_directive_1.BreadCrumbItemTemplateDirective)
    ], BreadCrumbComponent.prototype, "itemTemplate", void 0);
    tslib_1.__decorate([
        core_1.HostBinding('class.k-widget'),
        core_1.HostBinding('class.k-breadcrumb'),
        tslib_1.__metadata("design:type", Boolean)
    ], BreadCrumbComponent.prototype, "hostClasses", void 0);
    tslib_1.__decorate([
        core_1.HostBinding('class.k-breadcrumb-wrap'),
        tslib_1.__metadata("design:type", Boolean),
        tslib_1.__metadata("design:paramtypes", [])
    ], BreadCrumbComponent.prototype, "wrapMode", null);
    tslib_1.__decorate([
        core_1.HostBinding('attr.dir'),
        tslib_1.__metadata("design:type", String),
        tslib_1.__metadata("design:paramtypes", [])
    ], BreadCrumbComponent.prototype, "getDir", null);
    BreadCrumbComponent = tslib_1.__decorate([ tslib_1.__metadata("design:paramtypes", [core_1.ElementRef,
            core_1.ChangeDetectorRef,
            core_1.NgZone,
            kendo_angular_l10n_1.LocalizationService])
    ], BreadCrumbComponent);
BreadCrumbComponent.ɵfac = function BreadCrumbComponent_Factory(t) { return new (t || BreadCrumbComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.LocalizationService)); };
BreadCrumbComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: BreadCrumbComponent, selectors: [["kendo-breadcrumb"]], contentQueries: function BreadCrumbComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, item_template_directive_1.BreadCrumbItemTemplateDirective, 3);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.itemTemplate = _t.first);
    } }, viewQuery: function BreadCrumbComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c0, 3);
        ɵngcc0.ɵɵviewQuery(list_component_1.BreadCrumbListComponent, 3);
        ɵngcc0.ɵɵviewQuery(_c1, 1, core_1.ElementRef);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.resizeSensor = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.listComponent = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.itemsContainers = _t);
    } }, hostVars: 7, hostBindings: function BreadCrumbComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("dir", ctx.getDir);
        ɵngcc0.ɵɵclassProp("k-widget", ctx.hostClasses)("k-breadcrumb", ctx.hostClasses)("k-breadcrumb-wrap", ctx.wrapMode);
    } }, inputs: { items: "items", collapseMode: "collapseMode", separatorIcon: "separatorIcon" }, outputs: { itemClick: "itemClick" }, exportAs: ["kendoBreadCrumb"], features: [ɵngcc0.ɵɵProvidersFeature([
            kendo_angular_l10n_1.LocalizationService,
            {
                provide: kendo_angular_l10n_1.L10N_PREFIX,
                useValue: 'kendo.breadcrumb'
            }
        ])], decls: 6, vars: 12, consts: [["kendoBreadCrumbList", "", "class", "k-breadcrumb-root-item-container", 3, "items", "itemTemplate", "collapseMode", "separatorIcon", "itemClick", 4, "ngIf"], ["kendoBreadCrumbList", "", 1, "k-breadcrumb-container", 3, "items", "itemTemplate", "collapseMode", "separatorIcon", "ngClass", "itemClick"], ["itemsContainer", ""], [3, "rateLimit"], ["resizeSensor", ""], ["kendoBreadCrumbList", "", 1, "k-breadcrumb-root-item-container", 3, "items", "itemTemplate", "collapseMode", "separatorIcon", "itemClick"]], template: function BreadCrumbComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, BreadCrumbComponent_ol_0_Template, 3, 6, "ol", 0);
        ɵngcc0.ɵɵelementStart(1, "ol", 1, 2);
        ɵngcc0.ɵɵlistener("itemClick", function BreadCrumbComponent_Template_ol_itemClick_1_listener($event) { return ctx.itemClick.emit($event); });
        ɵngcc0.ɵɵpipe(3, "async");
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelement(4, "kendo-resize-sensor", 3, 4);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", ctx.collapseMode === "wrap");
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("items", ɵngcc0.ɵɵpipeBind1(3, 7, ctx.itemsData$))("itemTemplate", ctx.itemTemplate == null ? null : ctx.itemTemplate.templateRef)("collapseMode", ctx.collapseMode)("separatorIcon", ctx.separatorIcon)("ngClass", ɵngcc0.ɵɵpureFunction2(9, _c2, ctx.collapseMode === "wrap", ctx.collapseMode === "none"));
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵproperty("rateLimit", 1000);
    } }, directives: [ɵngcc2.NgIf, ɵngcc3.BreadCrumbListComponent, ɵngcc2.NgClass, ɵngcc4.ResizeSensorComponent], pipes: [ɵngcc2.AsyncPipe], encapsulation: 2 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(BreadCrumbComponent, [{
        type: core_1.Component,
        args: [{
                exportAs: 'kendoBreadCrumb',
                selector: 'kendo-breadcrumb',
                providers: [
                    kendo_angular_l10n_1.LocalizationService,
                    {
                        provide: kendo_angular_l10n_1.L10N_PREFIX,
                        useValue: 'kendo.breadcrumb'
                    }
                ],
                template: "\n        <ol\n            #itemsContainer\n            kendoBreadCrumbList\n            class=\"k-breadcrumb-root-item-container\"\n            *ngIf=\"collapseMode === 'wrap'\"\n            [items]=\"firstItem$ | async\"\n            [itemTemplate]=\"itemTemplate?.templateRef\"\n            [collapseMode]=\"collapseMode\"\n            [separatorIcon]=\"separatorIcon\"\n            (itemClick)=\"itemClick.emit($event)\"\n        ></ol>\n        <ol\n            #itemsContainer\n            kendoBreadCrumbList\n            class=\"k-breadcrumb-container\"\n            [items]=\"itemsData$ | async\"\n            [itemTemplate]=\"itemTemplate?.templateRef\"\n            [collapseMode]=\"collapseMode\"\n            [separatorIcon]=\"separatorIcon\"\n            (itemClick)=\"itemClick.emit($event)\"\n            [ngClass]=\"{ 'k-flex-wrap': collapseMode === 'wrap', 'k-flex-none': collapseMode === 'none' }\"\n        ></ol>\n        <kendo-resize-sensor [rateLimit]=\"1000\" #resizeSensor></kendo-resize-sensor>\n    "
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.NgZone }, { type: ɵngcc1.LocalizationService }]; }, { itemClick: [{
            type: core_1.Output
        }], hostClasses: [{
            type: core_1.HostBinding,
            args: ['class.k-widget']
        }, {
            type: core_1.HostBinding,
            args: ['class.k-breadcrumb']
        }], items: [{
            type: core_1.Input
        }], collapseMode: [{
            type: core_1.Input
        }], wrapMode: [{
            type: core_1.HostBinding,
            args: ['class.k-breadcrumb-wrap']
        }], getDir: [{
            type: core_1.HostBinding,
            args: ['attr.dir']
        }], separatorIcon: [{
            type: core_1.Input
        }], resizeSensor: [{
            type: core_1.ViewChild,
            args: ['resizeSensor', { static: true }]
        }], itemsContainers: [{
            type: core_1.ViewChildren,
            args: ['itemsContainer', { read: core_1.ElementRef }]
        }], listComponent: [{
            type: core_1.ViewChild,
            args: [list_component_1.BreadCrumbListComponent, { static: true }]
        }], itemTemplate: [{
            type: core_1.ContentChild,
            args: [item_template_directive_1.BreadCrumbItemTemplateDirective, { static: true }]
        }] }); })();
    return BreadCrumbComponent;
}());
exports.BreadCrumbComponent = BreadCrumbComponent;

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYnJlYWRjcnVtYi5jb21wb25lbnQuanMiLCJzb3VyY2VzIjpbImJyZWFkY3J1bWIuY29tcG9uZW50LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FhTztBQUNQO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQUE0QjtBQUM1QjtBQUNBO0FBQ0EiLCJzb3VyY2VzQ29udGVudCI6WyIvKiotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuKiBDb3B5cmlnaHQgwqkgMjAyMCBQcm9ncmVzcyBTb2Z0d2FyZSBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiogTGljZW5zZWQgdW5kZXIgY29tbWVyY2lhbCBsaWNlbnNlLiBTZWUgTElDRU5TRS5tZCBpbiB0aGUgcHJvamVjdCByb290IGZvciBtb3JlIGluZm9ybWF0aW9uXG4qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0c2xpYl8xID0gcmVxdWlyZShcInRzbGliXCIpO1xudmFyIGNvcmVfMSA9IHJlcXVpcmUoXCJAYW5ndWxhci9jb3JlXCIpO1xudmFyIHJ4anNfMSA9IHJlcXVpcmUoXCJyeGpzXCIpO1xudmFyIG9wZXJhdG9yc18xID0gcmVxdWlyZShcInJ4anMvb3BlcmF0b3JzXCIpO1xudmFyIGtlbmRvX2FuZ3VsYXJfY29tbW9uXzEgPSByZXF1aXJlKFwiQHByb2dyZXNzL2tlbmRvLWFuZ3VsYXItY29tbW9uXCIpO1xudmFyIGtlbmRvX2xpY2Vuc2luZ18xID0gcmVxdWlyZShcIkBwcm9ncmVzcy9rZW5kby1saWNlbnNpbmdcIik7XG52YXIgcGFja2FnZV9tZXRhZGF0YV8xID0gcmVxdWlyZShcIi4uL3BhY2thZ2UtbWV0YWRhdGFcIik7XG52YXIga2VuZG9fYW5ndWxhcl9sMTBuXzEgPSByZXF1aXJlKFwiQHByb2dyZXNzL2tlbmRvLWFuZ3VsYXItbDEwblwiKTtcbnZhciBpdGVtX3RlbXBsYXRlX2RpcmVjdGl2ZV8xID0gcmVxdWlyZShcIi4vdGVtcGxhdGUtZGlyZWN0aXZlcy9pdGVtLXRlbXBsYXRlLmRpcmVjdGl2ZVwiKTtcbnZhciB1dGlsXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL3V0aWxcIik7XG52YXIgbGlzdF9jb21wb25lbnRfMSA9IHJlcXVpcmUoXCIuL2xpc3QuY29tcG9uZW50XCIpO1xudmFyIHV0aWxfMiA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG4vKipcbiAqIFJlcHJlc2VudHMgdGhlIFtLZW5kbyBVSSBCcmVhZGNydW1iIGNvbXBvbmVudCBmb3IgQW5ndWxhcl0oeyUgc2x1ZyBvdmVydmlld19icmVhZGNydW1iICV9KS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMtbm8tcnVuXG4gKiBfQENvbXBvbmVudCh7XG4gKiAgICAgIHNlbGVjdG9yOiAnbXktYXBwJyxcbiAqICAgICAgdGVtcGxhdGU6IGBcbiAqICAgICAgICAgIDxrZW5kby1icmVhZGNydW1iXG4gKiAgICAgICAgICAgICAgW2l0ZW1zXT1cIml0ZW1zXCJcbiAqICAgICAgICAgICAgICAoaXRlbUNsaWNrKT1cIm9uSXRlbUNsaWNrKCRldmVudClcIj5cbiAqICAgICAgICAgIDwva2VuZG8tYnJlYWRjcnVtYj5cbiAqICAgICAgYFxuICogfSlcbiAqIGNsYXNzIEFwcENvbXBvbmVudCB7XG4gKiAgICAgIHB1YmxpYyBpdGVtczogQnJlYWRDcnVtYkl0ZW1bXSA9IFtcbiAqICAgICAgICAgIHsgdGV4dDogJ0hvbWUnLCB0aXRsZTogJ0hvbWUnLCBpY29uOiAnaG9tZScgfSxcbiAqICAgICAgICAgIHsgdGV4dDogJ0tpZHMnLCB0aXRsZTogJ0tpZHMnIH0sXG4gKiAgICAgICAgICB7IHRleHQ6ICc4eS0xNnknLCB0aXRsZTogJzh5LTE2eScsIGRpc2FibGVkOiB0cnVlIH0sXG4gKiAgICAgICAgICB7IHRleHQ6ICdOZXcgY29sbGVjdGlvbicsIHRpdGxlOiAnTmV3IGNvbGxlY3Rpb24nIH0sXG4gKiAgICAgICAgICB7IHRleHQ6ICdKZWFucycsIHRpdGxlOiAnSmVhbnMnIH1cbiAqICAgICAgXTtcbiAqXG4gKiAgICAgIHB1YmxpYyBvbkl0ZW1DbGljayhpdGVtOiBCcmVhZENydW1iSXRlbSk6IHZvaWQge1xuICogICAgICAgICAgY29uc29sZS5sb2coaXRlbSk7XG4gKiAgICAgIH1cbiAqIH1cbiAqIGBgYFxuICovXG52YXIgQnJlYWRDcnVtYkNvbXBvbmVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBCcmVhZENydW1iQ29tcG9uZW50KGVsLCBjZHIsIHpvbmUsIGxvY2FsaXphdGlvbikge1xuICAgICAgICB0aGlzLmVsID0gZWw7XG4gICAgICAgIHRoaXMuY2RyID0gY2RyO1xuICAgICAgICB0aGlzLnpvbmUgPSB6b25lO1xuICAgICAgICB0aGlzLmxvY2FsaXphdGlvbiA9IGxvY2FsaXphdGlvbjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpcmVzIHdoZW4gYSBCcmVhZGNydW1iIGl0ZW0gaXMgY2xpY2tlZC4gVGhlIGV2ZW50IHdpbGwgbm90IGJlIGZpcmVkIGJ5IGRpc2FibGVkIGl0ZW1zIGFuZCB0aGUgbGFzdCBpdGVtLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5pdGVtQ2xpY2sgPSBuZXcgY29yZV8xLkV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLmhvc3RDbGFzc2VzID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5faXRlbXMgPSBbXTtcbiAgICAgICAgdGhpcy5fY29sbGFwc2VNb2RlID0gJ2F1dG8nO1xuICAgICAgICB0aGlzLnVwZGF0ZUl0ZW1zID0gbmV3IHJ4anNfMS5SZXBsYXlTdWJqZWN0KCk7XG4gICAgICAgIHRoaXMuYWZ0ZXJWaWV3SW5pdCA9IG5ldyByeGpzXzEuU3ViamVjdCgpO1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMgPSBuZXcgcnhqc18xLlN1YnNjcmlwdGlvbigpO1xuICAgICAgICB0aGlzLmRpcmVjdGlvbiA9ICdsdHInO1xuICAgICAgICBrZW5kb19saWNlbnNpbmdfMS52YWxpZGF0ZVBhY2thZ2UocGFja2FnZV9tZXRhZGF0YV8xLnBhY2thZ2VNZXRhZGF0YSk7XG4gICAgICAgIHZhciB1cGRhdGVJdGVtcyQgPSB0aGlzLnVwZGF0ZUl0ZW1zLmFzT2JzZXJ2YWJsZSgpLnBpcGUob3BlcmF0b3JzXzEuc3RhcnRXaXRoKFtdKSk7XG4gICAgICAgIHRoaXMuZGlyZWN0aW9uID0gbG9jYWxpemF0aW9uLnJ0bCA/ICdydGwnIDogJ2x0cic7XG4gICAgICAgIHRoaXMuaXRlbXNEYXRhJCA9IHVwZGF0ZUl0ZW1zJC5waXBlKG9wZXJhdG9yc18xLm1hcChmdW5jdGlvbiAoaXRlbXMpIHsgcmV0dXJuIGl0ZW1zLmZpbHRlcihCb29sZWFuKTsgfSksIG9wZXJhdG9yc18xLm1hcChmdW5jdGlvbiAoaXRlbXMpIHtcbiAgICAgICAgICAgIHJldHVybiBpdGVtcy5tYXAoZnVuY3Rpb24gKGl0ZW0sIGluZGV4LCBjb2xsZWN0aW9uKSB7IHJldHVybiAoe1xuICAgICAgICAgICAgICAgIGNvbnRleHQ6IHtcbiAgICAgICAgICAgICAgICAgICAgY29sbGFwc2VkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgaXNMYXN0OiBpbmRleCA9PT0gY29sbGVjdGlvbi5sZW5ndGggLSAxLFxuICAgICAgICAgICAgICAgICAgICBpc0ZpcnN0OiBpbmRleCA9PT0gMFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZGF0YTogaXRlbVxuICAgICAgICAgICAgfSk7IH0pO1xuICAgICAgICB9KSwgb3BlcmF0b3JzXzEuc2hhcmUoKSk7XG4gICAgICAgIHRoaXMuZmlyc3RJdGVtJCA9IHVwZGF0ZUl0ZW1zJC5waXBlKG9wZXJhdG9yc18xLm1hcChmdW5jdGlvbiAoaXRlbXMpIHtcbiAgICAgICAgICAgIGlmIChpdGVtcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbGxhcHNlZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNMYXN0OiBpdGVtcy5sZW5ndGggPT09IDEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNGaXJzdDogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IGl0ZW1zWzBdXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9KSwgb3BlcmF0b3JzXzEuc2hhcmUoKSk7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCcmVhZENydW1iQ29tcG9uZW50LnByb3RvdHlwZSwgXCJpdGVtc1wiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2l0ZW1zO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGNvbGxlY3Rpb24gb2YgaXRlbXMgdGhhdCB3aWxsIGJlIHJlbmRlcmVkIGluIHRoZSBCcmVhZGNydW1iLlxuICAgICAgICAgKi9cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAoaXRlbXMpIHtcbiAgICAgICAgICAgIHRoaXMuX2l0ZW1zID0gaXRlbXMgfHwgW107XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUl0ZW1zLm5leHQodGhpcy5faXRlbXMpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQnJlYWRDcnVtYkNvbXBvbmVudC5wcm90b3R5cGUsIFwiY29sbGFwc2VNb2RlXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY29sbGFwc2VNb2RlO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogU3BlY2lmaWVzIHRoZSBjb2xsYXBzZSBtb2RlIG9mIHRoZSBCcmVhZGNydW1iIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgY29sbGFwc2VfbW9kZXNfYnJlYWRjcnVtYiAlfSkpLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGUgcG9zc2libGUgdmFsdWVzIGFyZTpcbiAgICAgICAgICogLSBgYXV0b2AgKGRlZmF1bHQpJm1kYXNoO2l0ZW1zIGFyZSBhdXRvbWF0aWNhbGx5IGNvbGxhcHNlZCBiYXNlZCBvbiB0aGUgd2lkdGggb2YgdGhlIEJyZWFkY3J1bWIuXG4gICAgICAgICAqIC0gYHdyYXBgJm1kYXNoO2l0ZW1zIGFyZSB3cmFwcGVkIG9uIG11bHRpcGxlIHJvd3MuXG4gICAgICAgICAqIC0gYG5vbmVgJm1kYXNoO2FsbCBpdGVtcyBhcmUgZXhwYW5kZWQgb24gdGhlIHNhbWUgcm93LlxuICAgICAgICAgKlxuICAgICAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiBhbmQgZXhhbXBsZSByZWZlciB0byB0aGUgW0NvbGxhcHNlIE1vZGVzXSh7JSBzbHVnIGNvbGxhcHNlX21vZGVzX2JyZWFkY3J1bWIgJX0pIGFydGljbGUuXG4gICAgICAgICAqL1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChtb2RlKSB7XG4gICAgICAgICAgICBpZiAoY29yZV8xLmlzRGV2TW9kZSgpICYmIFsnYXV0bycsICd3cmFwJywgJ25vbmUnXS5pbmRleE9mKG1vZGUpIDwgMCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBjb2xsYXBzZSBtb2RlLiBBbGxvd2VkIHZhbHVlcyBhcmUgXCJhdXRvXCIsIFwid3JhcFwiIG9yIFwibm9uZVwiLiBcXG5Gb3IgbW9yZSBkZXRhaWxzIHNlZSBodHRwczovL3d3dy50ZWxlcmlrLmNvbS9rZW5kby1hbmd1bGFyLXVpL2NvbXBvbmVudHMvbmF2aWdhdGlvbi9hcGkvQnJlYWRDcnVtYkNvbGxhcHNlTW9kZS8nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2NvbGxhcHNlTW9kZSA9IG1vZGUgfHwgJ2F1dG8nO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVJdGVtcy5uZXh0KHRoaXMuaXRlbXMpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQnJlYWRDcnVtYkNvbXBvbmVudC5wcm90b3R5cGUsIFwid3JhcE1vZGVcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbGxhcHNlTW9kZSA9PT0gJ3dyYXAnO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQnJlYWRDcnVtYkNvbXBvbmVudC5wcm90b3R5cGUsIFwiZ2V0RGlyXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kaXJlY3Rpb247XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIEJyZWFkQ3J1bWJDb21wb25lbnQucHJvdG90eXBlLm5nT25Jbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMuYWRkKHRoaXMubG9jYWxpemF0aW9uLmNoYW5nZXMuc3Vic2NyaWJlKGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgdmFyIHJ0bCA9IF9hLnJ0bDtcbiAgICAgICAgICAgIHJldHVybiAoX3RoaXMuZGlyZWN0aW9uID0gcnRsID8gJ3J0bCcgOiAnbHRyJyk7XG4gICAgICAgIH0pKTtcbiAgICB9O1xuICAgIEJyZWFkQ3J1bWJDb21wb25lbnQucHJvdG90eXBlLm5nQWZ0ZXJWaWV3SW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5hdHRhY2hSZXNpemVIYW5kbGVyKCk7XG4gICAgICAgIHRoaXMuYWZ0ZXJWaWV3SW5pdC5uZXh0KCk7XG4gICAgfTtcbiAgICBCcmVhZENydW1iQ29tcG9uZW50LnByb3RvdHlwZS5uZ09uRGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zLnVuc3Vic2NyaWJlKCk7XG4gICAgfTtcbiAgICBCcmVhZENydW1iQ29tcG9uZW50LnByb3RvdHlwZS5oYW5kbGVSZXNpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhdXRvQ29sbGFwc2VDYW5kaWRhdGVzID0gdGhpcy5saXN0Q29tcG9uZW50LnJlbmRlcmVkSXRlbXMudG9BcnJheSgpLmZpbHRlcihmdW5jdGlvbiAocmkpIHsgcmV0dXJuICFyaS5pdGVtLmNvbnRleHQuaXNGaXJzdCAmJiAhcmkuaXRlbS5jb250ZXh0LmlzTGFzdDsgfSkuc2xpY2UoKTtcbiAgICAgICAgdmFyIGNvbXBvbmVudFdpZHRoID0gdXRpbF8xLm91dGVyV2lkdGgodGhpcy5lbC5uYXRpdmVFbGVtZW50KTtcbiAgICAgICAgdmFyIGl0ZW1zQ29udGFpbmVyV2lkdGggPSBNYXRoLmZsb29yKHRoaXMuaXRlbXNDb250YWluZXJzXG4gICAgICAgICAgICAudG9BcnJheSgpXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChlbCkgeyByZXR1cm4gdXRpbF8xLm91dGVyV2lkdGgoZWwubmF0aXZlRWxlbWVudCk7IH0pXG4gICAgICAgICAgICAucmVkdWNlKGZ1bmN0aW9uIChhY2MsIGN1cnIpIHsgcmV0dXJuIGFjYyArIGN1cnI7IH0sIDApKTtcbiAgICAgICAgdmFyIG5leHRFeHBhbmRXaWR0aCA9IChhdXRvQ29sbGFwc2VDYW5kaWRhdGVzLnNsaWNlKCkucmV2ZXJzZSgpLmZpbmQodXRpbF8yLmNvbGxhcHNlZCkgfHwgeyB3aWR0aDogMCB9KS53aWR0aDtcbiAgICAgICAgLy8gLy8gc2hyaW5rXG4gICAgICAgIGlmIChjb21wb25lbnRXaWR0aCA8PSBpdGVtc0NvbnRhaW5lcldpZHRoICYmIGF1dG9Db2xsYXBzZUNhbmRpZGF0ZXMuZmluZCh1dGlsXzIuZXhwYW5kZWQpKSB7XG4gICAgICAgICAgICB1dGlsXzIuY29sbGFwc2VGaXJzdChhdXRvQ29sbGFwc2VDYW5kaWRhdGVzKTtcbiAgICAgICAgICAgIC8vIG5lZWRlZCBieSByZXNpemUgc2Vuc29yXG4gICAgICAgICAgICB0aGlzLmNkci5kZXRlY3RDaGFuZ2VzKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5oYW5kbGVSZXNpemUoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBleHBhbmRcbiAgICAgICAgaWYgKGNvbXBvbmVudFdpZHRoID4gaXRlbXNDb250YWluZXJXaWR0aCArIG5leHRFeHBhbmRXaWR0aCAmJiBhdXRvQ29sbGFwc2VDYW5kaWRhdGVzLmZpbmQodXRpbF8yLmNvbGxhcHNlZCkpIHtcbiAgICAgICAgICAgIHV0aWxfMi5leHBhbmRGaXJzdChhdXRvQ29sbGFwc2VDYW5kaWRhdGVzLnNsaWNlKCkucmV2ZXJzZSgpKTtcbiAgICAgICAgICAgIC8vIG5lZWRlZCBieSByZXNpemUgc2Vuc29yXG4gICAgICAgICAgICB0aGlzLmNkci5kZXRlY3RDaGFuZ2VzKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5oYW5kbGVSZXNpemUoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQnJlYWRDcnVtYkNvbXBvbmVudC5wcm90b3R5cGUuc2hvdWxkUmVzaXplID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4ga2VuZG9fYW5ndWxhcl9jb21tb25fMS5pc0RvY3VtZW50QXZhaWxhYmxlKCkgJiYgdGhpcy5jb2xsYXBzZU1vZGUgPT09ICdhdXRvJztcbiAgICB9O1xuICAgIEJyZWFkQ3J1bWJDb21wb25lbnQucHJvdG90eXBlLmF0dGFjaFJlc2l6ZUhhbmRsZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIC8vIHJlc2l6ZSB3aGVuOlxuICAgICAgICAvLyB0aGUgY29tcG9uZW50IGlzIGluaXRpYWxpemVkXG4gICAgICAgIC8vIHRoZSBjb250YWluZXIgaXMgcmVzaXplZFxuICAgICAgICAvLyBpdGVtcyBhcmUgYWRkZWQvcmVtb3ZlZFxuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMuYWRkKHJ4anNfMS5tZXJnZSh0aGlzLnJlc2l6ZVNlbnNvci5yZXNpemUsIHRoaXMuaXRlbXNEYXRhJCwgdGhpcy5hZnRlclZpZXdJbml0LmFzT2JzZXJ2YWJsZSgpKVxuICAgICAgICAgICAgLnBpcGUob3BlcmF0b3JzXzEuZmlsdGVyKGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLnNob3VsZFJlc2l6ZSgpOyB9KSlcbiAgICAgICAgICAgIC5zdWJzY3JpYmUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMuem9uZS5ydW5PdXRzaWRlQW5ndWxhcihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy56b25lLnJ1bihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMubGlzdENvbXBvbmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmhhbmRsZVJlc2l6ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnJlc2l6ZVNlbnNvci5hY2NlcHRTaXplKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pKTtcbiAgICB9O1xuICAgIHRzbGliXzEuX19kZWNvcmF0ZShbXG4gICAgICAgIGNvcmVfMS5JbnB1dCgpLFxuICAgICAgICB0c2xpYl8xLl9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBBcnJheSksXG4gICAgICAgIHRzbGliXzEuX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtBcnJheV0pXG4gICAgXSwgQnJlYWRDcnVtYkNvbXBvbmVudC5wcm90b3R5cGUsIFwiaXRlbXNcIiwgbnVsbCk7XG4gICAgdHNsaWJfMS5fX2RlY29yYXRlKFtcbiAgICAgICAgY29yZV8xLklucHV0KCksXG4gICAgICAgIHRzbGliXzEuX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbiAgICBdLCBCcmVhZENydW1iQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzZXBhcmF0b3JJY29uXCIsIHZvaWQgMCk7XG4gICAgdHNsaWJfMS5fX2RlY29yYXRlKFtcbiAgICAgICAgY29yZV8xLklucHV0KCksXG4gICAgICAgIHRzbGliXzEuX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZyksXG4gICAgICAgIHRzbGliXzEuX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtTdHJpbmddKVxuICAgIF0sIEJyZWFkQ3J1bWJDb21wb25lbnQucHJvdG90eXBlLCBcImNvbGxhcHNlTW9kZVwiLCBudWxsKTtcbiAgICB0c2xpYl8xLl9fZGVjb3JhdGUoW1xuICAgICAgICBjb3JlXzEuT3V0cHV0KCksXG4gICAgICAgIHRzbGliXzEuX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIGNvcmVfMS5FdmVudEVtaXR0ZXIpXG4gICAgXSwgQnJlYWRDcnVtYkNvbXBvbmVudC5wcm90b3R5cGUsIFwiaXRlbUNsaWNrXCIsIHZvaWQgMCk7XG4gICAgdHNsaWJfMS5fX2RlY29yYXRlKFtcbiAgICAgICAgY29yZV8xLlZpZXdDaGlsZCgncmVzaXplU2Vuc29yJywgeyBzdGF0aWM6IHRydWUgfSksXG4gICAgICAgIHRzbGliXzEuX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIGtlbmRvX2FuZ3VsYXJfY29tbW9uXzEuUmVzaXplU2Vuc29yQ29tcG9uZW50KVxuICAgIF0sIEJyZWFkQ3J1bWJDb21wb25lbnQucHJvdG90eXBlLCBcInJlc2l6ZVNlbnNvclwiLCB2b2lkIDApO1xuICAgIHRzbGliXzEuX19kZWNvcmF0ZShbXG4gICAgICAgIGNvcmVfMS5WaWV3Q2hpbGRyZW4oJ2l0ZW1zQ29udGFpbmVyJywgeyByZWFkOiBjb3JlXzEuRWxlbWVudFJlZiB9KSxcbiAgICAgICAgdHNsaWJfMS5fX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgY29yZV8xLlF1ZXJ5TGlzdClcbiAgICBdLCBCcmVhZENydW1iQ29tcG9uZW50LnByb3RvdHlwZSwgXCJpdGVtc0NvbnRhaW5lcnNcIiwgdm9pZCAwKTtcbiAgICB0c2xpYl8xLl9fZGVjb3JhdGUoW1xuICAgICAgICBjb3JlXzEuVmlld0NoaWxkKGxpc3RfY29tcG9uZW50XzEuQnJlYWRDcnVtYkxpc3RDb21wb25lbnQsIHsgc3RhdGljOiB0cnVlIH0pLFxuICAgICAgICB0c2xpYl8xLl9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBsaXN0X2NvbXBvbmVudF8xLkJyZWFkQ3J1bWJMaXN0Q29tcG9uZW50KVxuICAgIF0sIEJyZWFkQ3J1bWJDb21wb25lbnQucHJvdG90eXBlLCBcImxpc3RDb21wb25lbnRcIiwgdm9pZCAwKTtcbiAgICB0c2xpYl8xLl9fZGVjb3JhdGUoW1xuICAgICAgICBjb3JlXzEuQ29udGVudENoaWxkKGl0ZW1fdGVtcGxhdGVfZGlyZWN0aXZlXzEuQnJlYWRDcnVtYkl0ZW1UZW1wbGF0ZURpcmVjdGl2ZSwgeyBzdGF0aWM6IHRydWUgfSksXG4gICAgICAgIHRzbGliXzEuX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIGl0ZW1fdGVtcGxhdGVfZGlyZWN0aXZlXzEuQnJlYWRDcnVtYkl0ZW1UZW1wbGF0ZURpcmVjdGl2ZSlcbiAgICBdLCBCcmVhZENydW1iQ29tcG9uZW50LnByb3RvdHlwZSwgXCJpdGVtVGVtcGxhdGVcIiwgdm9pZCAwKTtcbiAgICB0c2xpYl8xLl9fZGVjb3JhdGUoW1xuICAgICAgICBjb3JlXzEuSG9zdEJpbmRpbmcoJ2NsYXNzLmstd2lkZ2V0JyksXG4gICAgICAgIGNvcmVfMS5Ib3N0QmluZGluZygnY2xhc3Muay1icmVhZGNydW1iJyksXG4gICAgICAgIHRzbGliXzEuX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG4gICAgXSwgQnJlYWRDcnVtYkNvbXBvbmVudC5wcm90b3R5cGUsIFwiaG9zdENsYXNzZXNcIiwgdm9pZCAwKTtcbiAgICB0c2xpYl8xLl9fZGVjb3JhdGUoW1xuICAgICAgICBjb3JlXzEuSG9zdEJpbmRpbmcoJ2NsYXNzLmstYnJlYWRjcnVtYi13cmFwJyksXG4gICAgICAgIHRzbGliXzEuX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pLFxuICAgICAgICB0c2xpYl8xLl9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSlcbiAgICBdLCBCcmVhZENydW1iQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ3cmFwTW9kZVwiLCBudWxsKTtcbiAgICB0c2xpYl8xLl9fZGVjb3JhdGUoW1xuICAgICAgICBjb3JlXzEuSG9zdEJpbmRpbmcoJ2F0dHIuZGlyJyksXG4gICAgICAgIHRzbGliXzEuX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZyksXG4gICAgICAgIHRzbGliXzEuX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKVxuICAgIF0sIEJyZWFkQ3J1bWJDb21wb25lbnQucHJvdG90eXBlLCBcImdldERpclwiLCBudWxsKTtcbiAgICBCcmVhZENydW1iQ29tcG9uZW50ID0gdHNsaWJfMS5fX2RlY29yYXRlKFtcbiAgICAgICAgY29yZV8xLkNvbXBvbmVudCh7XG4gICAgICAgICAgICBleHBvcnRBczogJ2tlbmRvQnJlYWRDcnVtYicsXG4gICAgICAgICAgICBzZWxlY3RvcjogJ2tlbmRvLWJyZWFkY3J1bWInLFxuICAgICAgICAgICAgcHJvdmlkZXJzOiBbXG4gICAgICAgICAgICAgICAga2VuZG9fYW5ndWxhcl9sMTBuXzEuTG9jYWxpemF0aW9uU2VydmljZSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHByb3ZpZGU6IGtlbmRvX2FuZ3VsYXJfbDEwbl8xLkwxME5fUFJFRklYLFxuICAgICAgICAgICAgICAgICAgICB1c2VWYWx1ZTogJ2tlbmRvLmJyZWFkY3J1bWInXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIHRlbXBsYXRlOiBcIlxcbiAgICAgICAgPG9sXFxuICAgICAgICAgICAgI2l0ZW1zQ29udGFpbmVyXFxuICAgICAgICAgICAga2VuZG9CcmVhZENydW1iTGlzdFxcbiAgICAgICAgICAgIGNsYXNzPVxcXCJrLWJyZWFkY3J1bWItcm9vdC1pdGVtLWNvbnRhaW5lclxcXCJcXG4gICAgICAgICAgICAqbmdJZj1cXFwiY29sbGFwc2VNb2RlID09PSAnd3JhcCdcXFwiXFxuICAgICAgICAgICAgW2l0ZW1zXT1cXFwiZmlyc3RJdGVtJCB8IGFzeW5jXFxcIlxcbiAgICAgICAgICAgIFtpdGVtVGVtcGxhdGVdPVxcXCJpdGVtVGVtcGxhdGU/LnRlbXBsYXRlUmVmXFxcIlxcbiAgICAgICAgICAgIFtjb2xsYXBzZU1vZGVdPVxcXCJjb2xsYXBzZU1vZGVcXFwiXFxuICAgICAgICAgICAgW3NlcGFyYXRvckljb25dPVxcXCJzZXBhcmF0b3JJY29uXFxcIlxcbiAgICAgICAgICAgIChpdGVtQ2xpY2spPVxcXCJpdGVtQ2xpY2suZW1pdCgkZXZlbnQpXFxcIlxcbiAgICAgICAgPjwvb2w+XFxuICAgICAgICA8b2xcXG4gICAgICAgICAgICAjaXRlbXNDb250YWluZXJcXG4gICAgICAgICAgICBrZW5kb0JyZWFkQ3J1bWJMaXN0XFxuICAgICAgICAgICAgY2xhc3M9XFxcImstYnJlYWRjcnVtYi1jb250YWluZXJcXFwiXFxuICAgICAgICAgICAgW2l0ZW1zXT1cXFwiaXRlbXNEYXRhJCB8IGFzeW5jXFxcIlxcbiAgICAgICAgICAgIFtpdGVtVGVtcGxhdGVdPVxcXCJpdGVtVGVtcGxhdGU/LnRlbXBsYXRlUmVmXFxcIlxcbiAgICAgICAgICAgIFtjb2xsYXBzZU1vZGVdPVxcXCJjb2xsYXBzZU1vZGVcXFwiXFxuICAgICAgICAgICAgW3NlcGFyYXRvckljb25dPVxcXCJzZXBhcmF0b3JJY29uXFxcIlxcbiAgICAgICAgICAgIChpdGVtQ2xpY2spPVxcXCJpdGVtQ2xpY2suZW1pdCgkZXZlbnQpXFxcIlxcbiAgICAgICAgICAgIFtuZ0NsYXNzXT1cXFwieyAnay1mbGV4LXdyYXAnOiBjb2xsYXBzZU1vZGUgPT09ICd3cmFwJywgJ2stZmxleC1ub25lJzogY29sbGFwc2VNb2RlID09PSAnbm9uZScgfVxcXCJcXG4gICAgICAgID48L29sPlxcbiAgICAgICAgPGtlbmRvLXJlc2l6ZS1zZW5zb3IgW3JhdGVMaW1pdF09XFxcIjEwMDBcXFwiICNyZXNpemVTZW5zb3I+PC9rZW5kby1yZXNpemUtc2Vuc29yPlxcbiAgICBcIlxuICAgICAgICB9KSxcbiAgICAgICAgdHNsaWJfMS5fX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW2NvcmVfMS5FbGVtZW50UmVmLFxuICAgICAgICAgICAgY29yZV8xLkNoYW5nZURldGVjdG9yUmVmLFxuICAgICAgICAgICAgY29yZV8xLk5nWm9uZSxcbiAgICAgICAgICAgIGtlbmRvX2FuZ3VsYXJfbDEwbl8xLkxvY2FsaXphdGlvblNlcnZpY2VdKVxuICAgIF0sIEJyZWFkQ3J1bWJDb21wb25lbnQpO1xuICAgIHJldHVybiBCcmVhZENydW1iQ29tcG9uZW50O1xufSgpKTtcbmV4cG9ydHMuQnJlYWRDcnVtYkNvbXBvbmVudCA9IEJyZWFkQ3J1bWJDb21wb25lbnQ7XG4iXX0=