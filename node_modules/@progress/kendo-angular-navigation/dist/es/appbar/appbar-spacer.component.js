/**-----------------------------------------------------------------------------------------
* Copyright © 2020 Progress Software Corporation. All rights reserved.
* Licensed under commercial license. See LICENSE.md in the project root for more information
*-------------------------------------------------------------------------------------------*/
import * as tslib_1 from "tslib";
import { Component, HostBinding, Input, Renderer2, ElementRef } from '@angular/core';
import { isPresent } from '../common/util';
/**
 * Represents the [Kendo UI AppBarSpacer component for Angular]({% slug contentarrangement_appbar %}#toc-spacings).
 * Used to give additional white space between the AppBar sections and provides a way for customizing its width.
 *
 * @example
 *
 * ```ts-no-run
 *  * _@Component({
 *    selector: 'my-app',
 *    template: `
 *        <kendo-appbar>
 *            <kendo-appbar-section>
 *                 <button class="k-button k-button-clear">
 *                     <kendo-icon [name]="'menu'"></kendo-icon>
 *                 </button>
 *            </kendo-appbar-section>
 *
 *            <kendo-appbar-spacer></kendo-appbar-spacer>
 *
 *            <kendo-appbar-section>
 *                <h2>Page Title</h2>
 *            </kendo-appbar-section>
 *        </kendo-appbar>
 *    `
 * })
 * class AppComponent {}
 * ```
 */
import * as ɵngcc0 from '@angular/core';
var AppBarSpacerComponent = /** @class */ (function () {
    function AppBarSpacerComponent(renderer, element) {
        this.renderer = renderer;
        this.element = element;
        this.hostClass = true;
    }
    Object.defineProperty(AppBarSpacerComponent.prototype, "sizedClass", {
        get: function () {
            return isPresent(this.width);
        },
        enumerable: true,
        configurable: true
    });
    AppBarSpacerComponent.prototype.ngAfterViewInit = function () {
        if (isPresent(this.width)) {
            var element = this.element.nativeElement;
            this.renderer.setStyle(element, 'flexBasis', this.width);
        }
    };
    tslib_1.__decorate([
        HostBinding('class.k-appbar-spacer'),
        tslib_1.__metadata("design:type", Boolean)
    ], AppBarSpacerComponent.prototype, "hostClass", void 0);
    tslib_1.__decorate([
        HostBinding('class.k-appbar-spacer-sized'),
        tslib_1.__metadata("design:type", Boolean),
        tslib_1.__metadata("design:paramtypes", [])
    ], AppBarSpacerComponent.prototype, "sizedClass", null);
    tslib_1.__decorate([
        Input(),
        tslib_1.__metadata("design:type", String)
    ], AppBarSpacerComponent.prototype, "width", void 0);
    AppBarSpacerComponent = tslib_1.__decorate([ tslib_1.__metadata("design:paramtypes", [Renderer2, ElementRef])
    ], AppBarSpacerComponent);
AppBarSpacerComponent.ɵfac = function AppBarSpacerComponent_Factory(t) { return new (t || AppBarSpacerComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
AppBarSpacerComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: AppBarSpacerComponent, selectors: [["kendo-appbar-spacer"]], hostVars: 4, hostBindings: function AppBarSpacerComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("k-appbar-spacer", ctx.hostClass)("k-appbar-spacer-sized", ctx.sizedClass);
    } }, inputs: { width: "width" }, decls: 0, vars: 0, template: function AppBarSpacerComponent_Template(rf, ctx) { }, encapsulation: 2 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(AppBarSpacerComponent, [{
        type: Component,
        args: [{
                selector: 'kendo-appbar-spacer',
                template: ""
            }]
    }], function () { return [{ type: ɵngcc0.Renderer2 }, { type: ɵngcc0.ElementRef }]; }, { hostClass: [{
            type: HostBinding,
            args: ['class.k-appbar-spacer']
        }], sizedClass: [{
            type: HostBinding,
            args: ['class.k-appbar-spacer-sized']
        }], width: [{
            type: Input
        }] }); })();
    return AppBarSpacerComponent;
}());
export { AppBarSpacerComponent };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXBwYmFyLXNwYWNlci5jb21wb25lbnQuanMiLCJzb3VyY2VzIjpbImFwcGJhci1zcGFjZXIuY29tcG9uZW50LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUtPO0FBQ1A7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBQThCO0FBQzlCO0FBQ0E7QUFDQSIsInNvdXJjZXNDb250ZW50IjpbIi8qKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4qIENvcHlyaWdodCDCqSAyMDIwIFByb2dyZXNzIFNvZnR3YXJlIENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuKiBMaWNlbnNlZCB1bmRlciBjb21tZXJjaWFsIGxpY2Vuc2UuIFNlZSBMSUNFTlNFLm1kIGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIG1vcmUgaW5mb3JtYXRpb25cbiotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbmltcG9ydCAqIGFzIHRzbGliXzEgZnJvbSBcInRzbGliXCI7XG5pbXBvcnQgeyBDb21wb25lbnQsIEhvc3RCaW5kaW5nLCBJbnB1dCwgUmVuZGVyZXIyLCBFbGVtZW50UmVmIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBpc1ByZXNlbnQgfSBmcm9tICcuLi9jb21tb24vdXRpbCc7XG4vKipcbiAqIFJlcHJlc2VudHMgdGhlIFtLZW5kbyBVSSBBcHBCYXJTcGFjZXIgY29tcG9uZW50IGZvciBBbmd1bGFyXSh7JSBzbHVnIGNvbnRlbnRhcnJhbmdlbWVudF9hcHBiYXIgJX0jdG9jLXNwYWNpbmdzKS5cbiAqIFVzZWQgdG8gZ2l2ZSBhZGRpdGlvbmFsIHdoaXRlIHNwYWNlIGJldHdlZW4gdGhlIEFwcEJhciBzZWN0aW9ucyBhbmQgcHJvdmlkZXMgYSB3YXkgZm9yIGN1c3RvbWl6aW5nIGl0cyB3aWR0aC5cbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIGBgYHRzLW5vLXJ1blxuICogICogX0BDb21wb25lbnQoe1xuICogICAgc2VsZWN0b3I6ICdteS1hcHAnLFxuICogICAgdGVtcGxhdGU6IGBcbiAqICAgICAgICA8a2VuZG8tYXBwYmFyPlxuICogICAgICAgICAgICA8a2VuZG8tYXBwYmFyLXNlY3Rpb24+XG4gKiAgICAgICAgICAgICAgICAgPGJ1dHRvbiBjbGFzcz1cImstYnV0dG9uIGstYnV0dG9uLWNsZWFyXCI+XG4gKiAgICAgICAgICAgICAgICAgICAgIDxrZW5kby1pY29uIFtuYW1lXT1cIidtZW51J1wiPjwva2VuZG8taWNvbj5cbiAqICAgICAgICAgICAgICAgICA8L2J1dHRvbj5cbiAqICAgICAgICAgICAgPC9rZW5kby1hcHBiYXItc2VjdGlvbj5cbiAqXG4gKiAgICAgICAgICAgIDxrZW5kby1hcHBiYXItc3BhY2VyPjwva2VuZG8tYXBwYmFyLXNwYWNlcj5cbiAqXG4gKiAgICAgICAgICAgIDxrZW5kby1hcHBiYXItc2VjdGlvbj5cbiAqICAgICAgICAgICAgICAgIDxoMj5QYWdlIFRpdGxlPC9oMj5cbiAqICAgICAgICAgICAgPC9rZW5kby1hcHBiYXItc2VjdGlvbj5cbiAqICAgICAgICA8L2tlbmRvLWFwcGJhcj5cbiAqICAgIGBcbiAqIH0pXG4gKiBjbGFzcyBBcHBDb21wb25lbnQge31cbiAqIGBgYFxuICovXG52YXIgQXBwQmFyU3BhY2VyQ29tcG9uZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEFwcEJhclNwYWNlckNvbXBvbmVudChyZW5kZXJlciwgZWxlbWVudCkge1xuICAgICAgICB0aGlzLnJlbmRlcmVyID0gcmVuZGVyZXI7XG4gICAgICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICAgIHRoaXMuaG9zdENsYXNzID0gdHJ1ZTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFwcEJhclNwYWNlckNvbXBvbmVudC5wcm90b3R5cGUsIFwic2l6ZWRDbGFzc1wiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIGlzUHJlc2VudCh0aGlzLndpZHRoKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgQXBwQmFyU3BhY2VyQ29tcG9uZW50LnByb3RvdHlwZS5uZ0FmdGVyVmlld0luaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy53aWR0aCkpIHtcbiAgICAgICAgICAgIHZhciBlbGVtZW50ID0gdGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQ7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcmVyLnNldFN0eWxlKGVsZW1lbnQsICdmbGV4QmFzaXMnLCB0aGlzLndpZHRoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgdHNsaWJfMS5fX2RlY29yYXRlKFtcbiAgICAgICAgSG9zdEJpbmRpbmcoJ2NsYXNzLmstYXBwYmFyLXNwYWNlcicpLFxuICAgICAgICB0c2xpYl8xLl9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuICAgIF0sIEFwcEJhclNwYWNlckNvbXBvbmVudC5wcm90b3R5cGUsIFwiaG9zdENsYXNzXCIsIHZvaWQgMCk7XG4gICAgdHNsaWJfMS5fX2RlY29yYXRlKFtcbiAgICAgICAgSG9zdEJpbmRpbmcoJ2NsYXNzLmstYXBwYmFyLXNwYWNlci1zaXplZCcpLFxuICAgICAgICB0c2xpYl8xLl9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKSxcbiAgICAgICAgdHNsaWJfMS5fX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pXG4gICAgXSwgQXBwQmFyU3BhY2VyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzaXplZENsYXNzXCIsIG51bGwpO1xuICAgIHRzbGliXzEuX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIHRzbGliXzEuX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbiAgICBdLCBBcHBCYXJTcGFjZXJDb21wb25lbnQucHJvdG90eXBlLCBcIndpZHRoXCIsIHZvaWQgMCk7XG4gICAgQXBwQmFyU3BhY2VyQ29tcG9uZW50ID0gdHNsaWJfMS5fX2RlY29yYXRlKFtcbiAgICAgICAgQ29tcG9uZW50KHtcbiAgICAgICAgICAgIHNlbGVjdG9yOiAna2VuZG8tYXBwYmFyLXNwYWNlcicsXG4gICAgICAgICAgICB0ZW1wbGF0ZTogXCJcIlxuICAgICAgICB9KSxcbiAgICAgICAgdHNsaWJfMS5fX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW1JlbmRlcmVyMiwgRWxlbWVudFJlZl0pXG4gICAgXSwgQXBwQmFyU3BhY2VyQ29tcG9uZW50KTtcbiAgICByZXR1cm4gQXBwQmFyU3BhY2VyQ29tcG9uZW50O1xufSgpKTtcbmV4cG9ydCB7IEFwcEJhclNwYWNlckNvbXBvbmVudCB9O1xuIl19