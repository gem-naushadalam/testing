/**-----------------------------------------------------------------------------------------
* Copyright © 2020 Progress Software Corporation. All rights reserved.
* Licensed under commercial license. See LICENSE.md in the project root for more information
*-------------------------------------------------------------------------------------------*/
import * as tslib_1 from "tslib";
import { Component, Output, Input, EventEmitter, TemplateRef, ViewChildren, QueryList, ElementRef, NgZone } from '@angular/core';
import { fromEvent, merge } from 'rxjs';
import { filter, map } from 'rxjs/operators';
import { Keys } from '@progress/kendo-angular-common';
import { BREADCRUMB_ITEM_INDEX } from './models/constants';
import { BreadCrumbItemComponent } from './breadcrumb-item.component';
import { closestItem, itemIndex } from '../common/dom-queries';
import { isPresent } from '../common/util';
/**
 * @hidden
 */
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@angular/common';
import * as ɵngcc2 from './breadcrumb-item.component';
import * as ɵngcc3 from './template-directives/separator.directive';

const _c0 = ["kendoBreadCrumbList", ""];
function BreadCrumbListComponent_ng_container_0_li_1_span_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "span", 5);
} if (rf & 2) {
    const ctx_r7 = ɵngcc0.ɵɵnextContext(3);
    ɵngcc0.ɵɵproperty("icon", ctx_r7.separatorIcon);
} }
function BreadCrumbListComponent_ng_container_0_li_1_span_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "span", 5);
} if (rf & 2) {
    const ctx_r8 = ɵngcc0.ɵɵnextContext(3);
    ɵngcc0.ɵɵproperty("icon", ctx_r8.separatorIcon);
} }
function BreadCrumbListComponent_ng_container_0_li_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "li", 2, 3);
    ɵngcc0.ɵɵtemplate(2, BreadCrumbListComponent_ng_container_0_li_1_span_2_Template, 1, 1, "span", 4);
    ɵngcc0.ɵɵtemplate(3, BreadCrumbListComponent_ng_container_0_li_1_span_3_Template, 1, 1, "span", 4);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r9 = ɵngcc0.ɵɵnextContext();
    const item_r1 = ctx_r9.$implicit;
    const i_r2 = ctx_r9.index;
    const isFirst_r3 = ctx_r9.first;
    const isLast_r4 = ctx_r9.last;
    const ctx_r5 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("item", item_r1)("index", i_r2)("collapseMode", ctx_r5.collapseMode)("itemTemplate", ctx_r5.itemTemplate);
    ɵngcc0.ɵɵattribute("data-kendo-breadcrumb-index", i_r2);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r5.collapseMode === "wrap" && !isFirst_r3);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r5.collapseMode !== "wrap" && !isLast_r4 && !((item_r1 == null ? null : item_r1.context.collapsed) && (ctx_r5.items[i_r2 + 1] == null ? null : ctx_r5.items[i_r2 + 1].context.collapsed)));
} }
function BreadCrumbListComponent_ng_container_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, BreadCrumbListComponent_ng_container_0_li_1_Template, 4, 7, "li", 1);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const isFirst_r3 = ctx.first;
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !(ctx_r0.collapseMode === "wrap" && isFirst_r3) || ctx_r0.isRootItemContainer);
} }
let BreadCrumbListComponent = class BreadCrumbListComponent {
    constructor(el, zone) {
        this.el = el;
        this.zone = zone;
        this.items = [];
        this.collapseMode = 'auto';
        this.itemClick = new EventEmitter();
        const element = this.el.nativeElement;
        this.isRootItemContainer = element.classList.contains('k-breadcrumb-root-item-container');
        this.zone.runOutsideAngular(() => {
            const click$ = fromEvent(element, 'click');
            const enterKey$ = fromEvent(element, 'keydown').pipe(filter((ev /* KeyboardEvent causes lint error */) => ev.keyCode === Keys.Enter));
            this.domEventsSubscription = merge(click$, enterKey$)
                .pipe(map((ev) => ev.target), filter(e => !e.classList.contains('k-breadcrumb-delimiter-icon')), // do not trigger handler when a separator is clicked
            map(e => this.getItemIndex(e)), filter(isPresent), map(i => parseInt(i, 10)), map(i => this.items[i]), filter(item => !item.data.disabled && !item.context.isLast), map(item => item.data))
                .subscribe(el => {
                this.zone.run(() => this.itemClick.emit(el));
            });
        });
    }
    ngOnDestroy() {
        this.domEventsSubscription.unsubscribe();
    }
    getItemIndex(target) {
        const item = closestItem(target, BREADCRUMB_ITEM_INDEX, this.el.nativeElement);
        if (item) {
            return itemIndex(item, BREADCRUMB_ITEM_INDEX);
        }
    }
};
BreadCrumbListComponent.ɵfac = function BreadCrumbListComponent_Factory(t) { return new (t || BreadCrumbListComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
BreadCrumbListComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: BreadCrumbListComponent, selectors: [["", "kendoBreadCrumbList", ""]], viewQuery: function BreadCrumbListComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(BreadCrumbItemComponent, 3);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.renderedItems = _t);
    } }, inputs: { items: "items", collapseMode: "collapseMode", itemTemplate: "itemTemplate", separatorIcon: "separatorIcon" }, outputs: { itemClick: "itemClick" }, attrs: _c0, decls: 1, vars: 1, consts: [[4, "ngFor", "ngForOf"], ["kendoBreadCrumbItem", "", 3, "item", "index", "collapseMode", "itemTemplate", 4, "ngIf"], ["kendoBreadCrumbItem", "", 3, "item", "index", "collapseMode", "itemTemplate"], ["renderedItem", ""], ["kendoBreadCrumbSeparator", "", 3, "icon", 4, "ngIf"], ["kendoBreadCrumbSeparator", "", 3, "icon"]], template: function BreadCrumbListComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, BreadCrumbListComponent_ng_container_0_Template, 2, 1, "ng-container", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngForOf", ctx.items);
    } }, directives: [ɵngcc1.NgForOf, ɵngcc1.NgIf, ɵngcc2.BreadCrumbItemComponent, ɵngcc3.BreadCrumbSeparatorDirective], encapsulation: 2 });
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", Array)
], BreadCrumbListComponent.prototype, "items", void 0);
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", TemplateRef)
], BreadCrumbListComponent.prototype, "itemTemplate", void 0);
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", String)
], BreadCrumbListComponent.prototype, "collapseMode", void 0);
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", String)
], BreadCrumbListComponent.prototype, "separatorIcon", void 0);
tslib_1.__decorate([
    Output(),
    tslib_1.__metadata("design:type", EventEmitter)
], BreadCrumbListComponent.prototype, "itemClick", void 0);
tslib_1.__decorate([
    ViewChildren(BreadCrumbItemComponent, { static: true }),
    tslib_1.__metadata("design:type", QueryList)
], BreadCrumbListComponent.prototype, "renderedItems", void 0);
BreadCrumbListComponent = tslib_1.__decorate([ tslib_1.__metadata("design:paramtypes", [ElementRef, NgZone])
], BreadCrumbListComponent);
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(BreadCrumbListComponent, [{
        type: Component,
        args: [{
                selector: '[kendoBreadCrumbList]',
                template: `
        <ng-container *ngFor="let item of items; let i = index; let isFirst = first; let isLast = last">
            <li
                #renderedItem
                kendoBreadCrumbItem
                *ngIf="!(collapseMode === 'wrap' && isFirst) || isRootItemContainer"
                [attr.${BREADCRUMB_ITEM_INDEX}]="i"
                [item]="item"
                [index]="i"
                [collapseMode]="collapseMode"
                [itemTemplate]="itemTemplate"
            >
                <span kendoBreadCrumbSeparator [icon]="separatorIcon" *ngIf="collapseMode === 'wrap' && !isFirst"></span>
                <span
                    kendoBreadCrumbSeparator
                    [icon]="separatorIcon"
                    *ngIf="collapseMode !== 'wrap' && !isLast && !(item?.context.collapsed && items[i + 1]?.context.collapsed)"
                ></span>
            </li>
        </ng-container>
    `
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }]; }, { items: [{
            type: Input
        }], collapseMode: [{
            type: Input
        }], itemClick: [{
            type: Output
        }], itemTemplate: [{
            type: Input
        }], separatorIcon: [{
            type: Input
        }], renderedItems: [{
            type: ViewChildren,
            args: [BreadCrumbItemComponent, { static: true }]
        }] }); })();
export { BreadCrumbListComponent };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibGlzdC5jb21wb25lbnQuanMiLCJzb3VyY2VzIjpbImxpc3QuY29tcG9uZW50LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OzZJQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBeUJHO0FBQ0g7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBQTRCO0FBQzVCIiwic291cmNlc0NvbnRlbnQiOlsiLyoqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiogQ29weXJpZ2h0IMKpIDIwMjAgUHJvZ3Jlc3MgU29mdHdhcmUgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4qIExpY2Vuc2VkIHVuZGVyIGNvbW1lcmNpYWwgbGljZW5zZS4gU2VlIExJQ0VOU0UubWQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbW9yZSBpbmZvcm1hdGlvblxuKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuaW1wb3J0ICogYXMgdHNsaWJfMSBmcm9tIFwidHNsaWJcIjtcbmltcG9ydCB7IENvbXBvbmVudCwgT3V0cHV0LCBJbnB1dCwgRXZlbnRFbWl0dGVyLCBUZW1wbGF0ZVJlZiwgVmlld0NoaWxkcmVuLCBRdWVyeUxpc3QsIEVsZW1lbnRSZWYsIE5nWm9uZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgZnJvbUV2ZW50LCBtZXJnZSB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgZmlsdGVyLCBtYXAgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQgeyBLZXlzIH0gZnJvbSAnQHByb2dyZXNzL2tlbmRvLWFuZ3VsYXItY29tbW9uJztcbmltcG9ydCB7IEJSRUFEQ1JVTUJfSVRFTV9JTkRFWCB9IGZyb20gJy4vbW9kZWxzL2NvbnN0YW50cyc7XG5pbXBvcnQgeyBCcmVhZENydW1iSXRlbUNvbXBvbmVudCB9IGZyb20gJy4vYnJlYWRjcnVtYi1pdGVtLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBjbG9zZXN0SXRlbSwgaXRlbUluZGV4IH0gZnJvbSAnLi4vY29tbW9uL2RvbS1xdWVyaWVzJztcbmltcG9ydCB7IGlzUHJlc2VudCB9IGZyb20gJy4uL2NvbW1vbi91dGlsJztcbi8qKlxuICogQGhpZGRlblxuICovXG5sZXQgQnJlYWRDcnVtYkxpc3RDb21wb25lbnQgPSBjbGFzcyBCcmVhZENydW1iTGlzdENvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoZWwsIHpvbmUpIHtcbiAgICAgICAgdGhpcy5lbCA9IGVsO1xuICAgICAgICB0aGlzLnpvbmUgPSB6b25lO1xuICAgICAgICB0aGlzLml0ZW1zID0gW107XG4gICAgICAgIHRoaXMuY29sbGFwc2VNb2RlID0gJ2F1dG8nO1xuICAgICAgICB0aGlzLml0ZW1DbGljayA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgY29uc3QgZWxlbWVudCA9IHRoaXMuZWwubmF0aXZlRWxlbWVudDtcbiAgICAgICAgdGhpcy5pc1Jvb3RJdGVtQ29udGFpbmVyID0gZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoJ2stYnJlYWRjcnVtYi1yb290LWl0ZW0tY29udGFpbmVyJyk7XG4gICAgICAgIHRoaXMuem9uZS5ydW5PdXRzaWRlQW5ndWxhcigoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBjbGljayQgPSBmcm9tRXZlbnQoZWxlbWVudCwgJ2NsaWNrJyk7XG4gICAgICAgICAgICBjb25zdCBlbnRlcktleSQgPSBmcm9tRXZlbnQoZWxlbWVudCwgJ2tleWRvd24nKS5waXBlKGZpbHRlcigoZXYgLyogS2V5Ym9hcmRFdmVudCBjYXVzZXMgbGludCBlcnJvciAqLykgPT4gZXYua2V5Q29kZSA9PT0gS2V5cy5FbnRlcikpO1xuICAgICAgICAgICAgdGhpcy5kb21FdmVudHNTdWJzY3JpcHRpb24gPSBtZXJnZShjbGljayQsIGVudGVyS2V5JClcbiAgICAgICAgICAgICAgICAucGlwZShtYXAoKGV2KSA9PiBldi50YXJnZXQpLCBmaWx0ZXIoZSA9PiAhZS5jbGFzc0xpc3QuY29udGFpbnMoJ2stYnJlYWRjcnVtYi1kZWxpbWl0ZXItaWNvbicpKSwgLy8gZG8gbm90IHRyaWdnZXIgaGFuZGxlciB3aGVuIGEgc2VwYXJhdG9yIGlzIGNsaWNrZWRcbiAgICAgICAgICAgIG1hcChlID0+IHRoaXMuZ2V0SXRlbUluZGV4KGUpKSwgZmlsdGVyKGlzUHJlc2VudCksIG1hcChpID0+IHBhcnNlSW50KGksIDEwKSksIG1hcChpID0+IHRoaXMuaXRlbXNbaV0pLCBmaWx0ZXIoaXRlbSA9PiAhaXRlbS5kYXRhLmRpc2FibGVkICYmICFpdGVtLmNvbnRleHQuaXNMYXN0KSwgbWFwKGl0ZW0gPT4gaXRlbS5kYXRhKSlcbiAgICAgICAgICAgICAgICAuc3Vic2NyaWJlKGVsID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnpvbmUucnVuKCgpID0+IHRoaXMuaXRlbUNsaWNrLmVtaXQoZWwpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgbmdPbkRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuZG9tRXZlbnRzU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgfVxuICAgIGdldEl0ZW1JbmRleCh0YXJnZXQpIHtcbiAgICAgICAgY29uc3QgaXRlbSA9IGNsb3Nlc3RJdGVtKHRhcmdldCwgQlJFQURDUlVNQl9JVEVNX0lOREVYLCB0aGlzLmVsLm5hdGl2ZUVsZW1lbnQpO1xuICAgICAgICBpZiAoaXRlbSkge1xuICAgICAgICAgICAgcmV0dXJuIGl0ZW1JbmRleChpdGVtLCBCUkVBRENSVU1CX0lURU1fSU5ERVgpO1xuICAgICAgICB9XG4gICAgfVxufTtcbnRzbGliXzEuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICB0c2xpYl8xLl9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBBcnJheSlcbl0sIEJyZWFkQ3J1bWJMaXN0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJpdGVtc1wiLCB2b2lkIDApO1xudHNsaWJfMS5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIHRzbGliXzEuX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFRlbXBsYXRlUmVmKVxuXSwgQnJlYWRDcnVtYkxpc3RDb21wb25lbnQucHJvdG90eXBlLCBcIml0ZW1UZW1wbGF0ZVwiLCB2b2lkIDApO1xudHNsaWJfMS5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIHRzbGliXzEuX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIEJyZWFkQ3J1bWJMaXN0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJjb2xsYXBzZU1vZGVcIiwgdm9pZCAwKTtcbnRzbGliXzEuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICB0c2xpYl8xLl9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBCcmVhZENydW1iTGlzdENvbXBvbmVudC5wcm90b3R5cGUsIFwic2VwYXJhdG9ySWNvblwiLCB2b2lkIDApO1xudHNsaWJfMS5fX2RlY29yYXRlKFtcbiAgICBPdXRwdXQoKSxcbiAgICB0c2xpYl8xLl9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBFdmVudEVtaXR0ZXIpXG5dLCBCcmVhZENydW1iTGlzdENvbXBvbmVudC5wcm90b3R5cGUsIFwiaXRlbUNsaWNrXCIsIHZvaWQgMCk7XG50c2xpYl8xLl9fZGVjb3JhdGUoW1xuICAgIFZpZXdDaGlsZHJlbihCcmVhZENydW1iSXRlbUNvbXBvbmVudCwgeyBzdGF0aWM6IHRydWUgfSksXG4gICAgdHNsaWJfMS5fX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgUXVlcnlMaXN0KVxuXSwgQnJlYWRDcnVtYkxpc3RDb21wb25lbnQucHJvdG90eXBlLCBcInJlbmRlcmVkSXRlbXNcIiwgdm9pZCAwKTtcbkJyZWFkQ3J1bWJMaXN0Q29tcG9uZW50ID0gdHNsaWJfMS5fX2RlY29yYXRlKFtcbiAgICBDb21wb25lbnQoe1xuICAgICAgICBzZWxlY3RvcjogJ1trZW5kb0JyZWFkQ3J1bWJMaXN0XScsXG4gICAgICAgIHRlbXBsYXRlOiBgXG4gICAgICAgIDxuZy1jb250YWluZXIgKm5nRm9yPVwibGV0IGl0ZW0gb2YgaXRlbXM7IGxldCBpID0gaW5kZXg7IGxldCBpc0ZpcnN0ID0gZmlyc3Q7IGxldCBpc0xhc3QgPSBsYXN0XCI+XG4gICAgICAgICAgICA8bGlcbiAgICAgICAgICAgICAgICAjcmVuZGVyZWRJdGVtXG4gICAgICAgICAgICAgICAga2VuZG9CcmVhZENydW1iSXRlbVxuICAgICAgICAgICAgICAgICpuZ0lmPVwiIShjb2xsYXBzZU1vZGUgPT09ICd3cmFwJyAmJiBpc0ZpcnN0KSB8fCBpc1Jvb3RJdGVtQ29udGFpbmVyXCJcbiAgICAgICAgICAgICAgICBbYXR0ci4ke0JSRUFEQ1JVTUJfSVRFTV9JTkRFWH1dPVwiaVwiXG4gICAgICAgICAgICAgICAgW2l0ZW1dPVwiaXRlbVwiXG4gICAgICAgICAgICAgICAgW2luZGV4XT1cImlcIlxuICAgICAgICAgICAgICAgIFtjb2xsYXBzZU1vZGVdPVwiY29sbGFwc2VNb2RlXCJcbiAgICAgICAgICAgICAgICBbaXRlbVRlbXBsYXRlXT1cIml0ZW1UZW1wbGF0ZVwiXG4gICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgPHNwYW4ga2VuZG9CcmVhZENydW1iU2VwYXJhdG9yIFtpY29uXT1cInNlcGFyYXRvckljb25cIiAqbmdJZj1cImNvbGxhcHNlTW9kZSA9PT0gJ3dyYXAnICYmICFpc0ZpcnN0XCI+PC9zcGFuPlxuICAgICAgICAgICAgICAgIDxzcGFuXG4gICAgICAgICAgICAgICAgICAgIGtlbmRvQnJlYWRDcnVtYlNlcGFyYXRvclxuICAgICAgICAgICAgICAgICAgICBbaWNvbl09XCJzZXBhcmF0b3JJY29uXCJcbiAgICAgICAgICAgICAgICAgICAgKm5nSWY9XCJjb2xsYXBzZU1vZGUgIT09ICd3cmFwJyAmJiAhaXNMYXN0ICYmICEoaXRlbT8uY29udGV4dC5jb2xsYXBzZWQgJiYgaXRlbXNbaSArIDFdPy5jb250ZXh0LmNvbGxhcHNlZClcIlxuICAgICAgICAgICAgICAgID48L3NwYW4+XG4gICAgICAgICAgICA8L2xpPlxuICAgICAgICA8L25nLWNvbnRhaW5lcj5cbiAgICBgXG4gICAgfSksXG4gICAgdHNsaWJfMS5fX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0VsZW1lbnRSZWYsIE5nWm9uZV0pXG5dLCBCcmVhZENydW1iTGlzdENvbXBvbmVudCk7XG5leHBvcnQgeyBCcmVhZENydW1iTGlzdENvbXBvbmVudCB9O1xuIl19