/**-----------------------------------------------------------------------------------------
* Copyright © 2020 Progress Software Corporation. All rights reserved.
* Licensed under commercial license. See LICENSE.md in the project root for more information
*-------------------------------------------------------------------------------------------*/
import * as tslib_1 from "tslib";
import { Component, ContentChild, Input, Output, EventEmitter, ViewChild, HostBinding, ElementRef, ChangeDetectorRef, NgZone, ViewChildren, QueryList, isDevMode } from '@angular/core';
import { Subscription, ReplaySubject, merge, Subject } from 'rxjs';
import { filter, map, share, startWith } from 'rxjs/operators';
import { ResizeSensorComponent, isDocumentAvailable } from '@progress/kendo-angular-common';
import { validatePackage } from '@progress/kendo-licensing';
import { packageMetadata } from '../package-metadata';
import { LocalizationService, L10N_PREFIX } from '@progress/kendo-angular-l10n';
import { BreadCrumbItemTemplateDirective } from './template-directives/item-template.directive';
import { outerWidth } from '../common/util';
import { BreadCrumbListComponent } from './list.component';
import { collapsed, expanded, collapseFirst, expandFirst } from './util';
/**
 * Represents the [Kendo UI Breadcrumb component for Angular]({% slug overview_breadcrumb %}).
 *
 * @example
 * ```ts-no-run
 * _@Component({
 *      selector: 'my-app',
 *      template: `
 *          <kendo-breadcrumb
 *              [items]="items"
 *              (itemClick)="onItemClick($event)">
 *          </kendo-breadcrumb>
 *      `
 * })
 * class AppComponent {
 *      public items: BreadCrumbItem[] = [
 *          { text: 'Home', title: 'Home', icon: 'home' },
 *          { text: 'Kids', title: 'Kids' },
 *          { text: '8y-16y', title: '8y-16y', disabled: true },
 *          { text: 'New collection', title: 'New collection' },
 *          { text: 'Jeans', title: 'Jeans' }
 *      ];
 *
 *      public onItemClick(item: BreadCrumbItem): void {
 *          console.log(item);
 *      }
 * }
 * ```
 */
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@progress/kendo-angular-l10n';
import * as ɵngcc2 from '@angular/common';
import * as ɵngcc3 from './list.component';
import * as ɵngcc4 from '@progress/kendo-angular-common';

const _c0 = ["resizeSensor"];
const _c1 = ["itemsContainer"];
function BreadCrumbComponent_ol_0_Template(rf, ctx) { if (rf & 1) {
    const _r5 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "ol", 5, 2);
    ɵngcc0.ɵɵlistener("itemClick", function BreadCrumbComponent_ol_0_Template_ol_itemClick_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r5); const ctx_r4 = ɵngcc0.ɵɵnextContext(); return ctx_r4.itemClick.emit($event); });
    ɵngcc0.ɵɵpipe(2, "async");
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("items", ɵngcc0.ɵɵpipeBind1(2, 4, ctx_r0.firstItem$))("itemTemplate", ctx_r0.itemTemplate == null ? null : ctx_r0.itemTemplate.templateRef)("collapseMode", ctx_r0.collapseMode)("separatorIcon", ctx_r0.separatorIcon);
} }
const _c2 = function (a0, a1) { return { "k-flex-wrap": a0, "k-flex-none": a1 }; };
let BreadCrumbComponent = class BreadCrumbComponent {
    constructor(el, cdr, zone, localization) {
        this.el = el;
        this.cdr = cdr;
        this.zone = zone;
        this.localization = localization;
        /**
         * Fires when a Breadcrumb item is clicked. The event will not be fired by disabled items and the last item.
         */
        this.itemClick = new EventEmitter();
        this.hostClasses = true;
        this._items = [];
        this._collapseMode = 'auto';
        this.updateItems = new ReplaySubject();
        this.afterViewInit = new Subject();
        this.subscriptions = new Subscription();
        this.direction = 'ltr';
        validatePackage(packageMetadata);
        const updateItems$ = this.updateItems.asObservable().pipe(startWith([]));
        this.direction = localization.rtl ? 'rtl' : 'ltr';
        this.itemsData$ = updateItems$.pipe(map(items => items.filter(Boolean)), map(items => items.map((item, index, collection) => ({
            context: {
                collapsed: false,
                isLast: index === collection.length - 1,
                isFirst: index === 0
            },
            data: item
        }))), share());
        this.firstItem$ = updateItems$.pipe(map(items => {
            if (items.length > 0) {
                return [
                    {
                        context: {
                            collapsed: false,
                            isLast: items.length === 1,
                            isFirst: true
                        },
                        data: items[0]
                    }
                ];
            }
            return [];
        }), share());
    }
    /**
     * The collection of items that will be rendered in the Breadcrumb.
     */
    set items(items) {
        this._items = items || [];
        this.updateItems.next(this._items);
    }
    get items() {
        return this._items;
    }
    /**
     * Specifies the collapse mode of the Breadcrumb ([see example]({% slug collapse_modes_breadcrumb %})).
     *
     * The possible values are:
     * - `auto` (default)&mdash;items are automatically collapsed based on the width of the Breadcrumb.
     * - `wrap`&mdash;items are wrapped on multiple rows.
     * - `none`&mdash;all items are expanded on the same row.
     *
     * For more information and example refer to the [Collapse Modes]({% slug collapse_modes_breadcrumb %}) article.
     */
    set collapseMode(mode) {
        if (isDevMode() && ['auto', 'wrap', 'none'].indexOf(mode) < 0) {
            throw new Error('Invalid collapse mode. Allowed values are "auto", "wrap" or "none". \nFor more details see https://www.telerik.com/kendo-angular-ui/components/navigation/api/BreadCrumbCollapseMode/');
        }
        this._collapseMode = mode || 'auto';
        this.updateItems.next(this.items);
    }
    get collapseMode() {
        return this._collapseMode;
    }
    get wrapMode() {
        return this.collapseMode === 'wrap';
    }
    get getDir() {
        return this.direction;
    }
    ngOnInit() {
        this.subscriptions.add(this.localization.changes.subscribe(({ rtl }) => (this.direction = rtl ? 'rtl' : 'ltr')));
    }
    ngAfterViewInit() {
        this.attachResizeHandler();
        this.afterViewInit.next();
    }
    ngOnDestroy() {
        this.subscriptions.unsubscribe();
    }
    handleResize() {
        const autoCollapseCandidates = [
            ...this.listComponent.renderedItems.toArray().filter(ri => !ri.item.context.isFirst && !ri.item.context.isLast)
        ];
        const componentWidth = outerWidth(this.el.nativeElement);
        const itemsContainerWidth = Math.floor(this.itemsContainers
            .toArray()
            .map(el => outerWidth(el.nativeElement))
            .reduce((acc, curr) => acc + curr, 0));
        const nextExpandWidth = ([...autoCollapseCandidates].reverse().find(collapsed) || { width: 0 }).width;
        // // shrink
        if (componentWidth <= itemsContainerWidth && autoCollapseCandidates.find(expanded)) {
            collapseFirst(autoCollapseCandidates);
            // needed by resize sensor
            this.cdr.detectChanges();
            return this.handleResize();
        }
        // expand
        if (componentWidth > itemsContainerWidth + nextExpandWidth && autoCollapseCandidates.find(collapsed)) {
            expandFirst([...autoCollapseCandidates].reverse());
            // needed by resize sensor
            this.cdr.detectChanges();
            return this.handleResize();
        }
    }
    shouldResize() {
        return isDocumentAvailable() && this.collapseMode === 'auto';
    }
    attachResizeHandler() {
        // resize when:
        // the component is initialized
        // the container is resized
        // items are added/removed
        this.subscriptions.add(merge(this.resizeSensor.resize, this.itemsData$, this.afterViewInit.asObservable())
            .pipe(filter(() => this.shouldResize()))
            .subscribe(() => {
            this.zone.runOutsideAngular(() => setTimeout(() => {
                this.zone.run(() => {
                    if (this.listComponent) {
                        this.handleResize();
                        this.resizeSensor.acceptSize();
                    }
                });
            }));
        }));
    }
};
BreadCrumbComponent.ɵfac = function BreadCrumbComponent_Factory(t) { return new (t || BreadCrumbComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.LocalizationService)); };
BreadCrumbComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: BreadCrumbComponent, selectors: [["kendo-breadcrumb"]], contentQueries: function BreadCrumbComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, BreadCrumbItemTemplateDirective, 3);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.itemTemplate = _t.first);
    } }, viewQuery: function BreadCrumbComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c0, 3);
        ɵngcc0.ɵɵviewQuery(BreadCrumbListComponent, 3);
        ɵngcc0.ɵɵviewQuery(_c1, 1, ElementRef);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.resizeSensor = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.listComponent = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.itemsContainers = _t);
    } }, hostVars: 7, hostBindings: function BreadCrumbComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("dir", ctx.getDir);
        ɵngcc0.ɵɵclassProp("k-widget", ctx.hostClasses)("k-breadcrumb", ctx.hostClasses)("k-breadcrumb-wrap", ctx.wrapMode);
    } }, inputs: { items: "items", collapseMode: "collapseMode", separatorIcon: "separatorIcon" }, outputs: { itemClick: "itemClick" }, exportAs: ["kendoBreadCrumb"], features: [ɵngcc0.ɵɵProvidersFeature([
            LocalizationService,
            {
                provide: L10N_PREFIX,
                useValue: 'kendo.breadcrumb'
            }
        ])], decls: 6, vars: 12, consts: [["kendoBreadCrumbList", "", "class", "k-breadcrumb-root-item-container", 3, "items", "itemTemplate", "collapseMode", "separatorIcon", "itemClick", 4, "ngIf"], ["kendoBreadCrumbList", "", 1, "k-breadcrumb-container", 3, "items", "itemTemplate", "collapseMode", "separatorIcon", "ngClass", "itemClick"], ["itemsContainer", ""], [3, "rateLimit"], ["resizeSensor", ""], ["kendoBreadCrumbList", "", 1, "k-breadcrumb-root-item-container", 3, "items", "itemTemplate", "collapseMode", "separatorIcon", "itemClick"]], template: function BreadCrumbComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, BreadCrumbComponent_ol_0_Template, 3, 6, "ol", 0);
        ɵngcc0.ɵɵelementStart(1, "ol", 1, 2);
        ɵngcc0.ɵɵlistener("itemClick", function BreadCrumbComponent_Template_ol_itemClick_1_listener($event) { return ctx.itemClick.emit($event); });
        ɵngcc0.ɵɵpipe(3, "async");
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelement(4, "kendo-resize-sensor", 3, 4);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", ctx.collapseMode === "wrap");
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("items", ɵngcc0.ɵɵpipeBind1(3, 7, ctx.itemsData$))("itemTemplate", ctx.itemTemplate == null ? null : ctx.itemTemplate.templateRef)("collapseMode", ctx.collapseMode)("separatorIcon", ctx.separatorIcon)("ngClass", ɵngcc0.ɵɵpureFunction2(9, _c2, ctx.collapseMode === "wrap", ctx.collapseMode === "none"));
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵproperty("rateLimit", 1000);
    } }, directives: [ɵngcc2.NgIf, ɵngcc3.BreadCrumbListComponent, ɵngcc2.NgClass, ɵngcc4.ResizeSensorComponent], pipes: [ɵngcc2.AsyncPipe], encapsulation: 2 });
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", Array),
    tslib_1.__metadata("design:paramtypes", [Array])
], BreadCrumbComponent.prototype, "items", null);
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", String)
], BreadCrumbComponent.prototype, "separatorIcon", void 0);
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", String),
    tslib_1.__metadata("design:paramtypes", [String])
], BreadCrumbComponent.prototype, "collapseMode", null);
tslib_1.__decorate([
    Output(),
    tslib_1.__metadata("design:type", EventEmitter)
], BreadCrumbComponent.prototype, "itemClick", void 0);
tslib_1.__decorate([
    ViewChild('resizeSensor', { static: true }),
    tslib_1.__metadata("design:type", ResizeSensorComponent)
], BreadCrumbComponent.prototype, "resizeSensor", void 0);
tslib_1.__decorate([
    ViewChildren('itemsContainer', { read: ElementRef }),
    tslib_1.__metadata("design:type", QueryList)
], BreadCrumbComponent.prototype, "itemsContainers", void 0);
tslib_1.__decorate([
    ViewChild(BreadCrumbListComponent, { static: true }),
    tslib_1.__metadata("design:type", BreadCrumbListComponent)
], BreadCrumbComponent.prototype, "listComponent", void 0);
tslib_1.__decorate([
    ContentChild(BreadCrumbItemTemplateDirective, { static: true }),
    tslib_1.__metadata("design:type", BreadCrumbItemTemplateDirective)
], BreadCrumbComponent.prototype, "itemTemplate", void 0);
tslib_1.__decorate([
    HostBinding('class.k-widget'),
    HostBinding('class.k-breadcrumb'),
    tslib_1.__metadata("design:type", Boolean)
], BreadCrumbComponent.prototype, "hostClasses", void 0);
tslib_1.__decorate([
    HostBinding('class.k-breadcrumb-wrap'),
    tslib_1.__metadata("design:type", Boolean),
    tslib_1.__metadata("design:paramtypes", [])
], BreadCrumbComponent.prototype, "wrapMode", null);
tslib_1.__decorate([
    HostBinding('attr.dir'),
    tslib_1.__metadata("design:type", String),
    tslib_1.__metadata("design:paramtypes", [])
], BreadCrumbComponent.prototype, "getDir", null);
BreadCrumbComponent = tslib_1.__decorate([ tslib_1.__metadata("design:paramtypes", [ElementRef,
        ChangeDetectorRef,
        NgZone,
        LocalizationService])
], BreadCrumbComponent);
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(BreadCrumbComponent, [{
        type: Component,
        args: [{
                exportAs: 'kendoBreadCrumb',
                selector: 'kendo-breadcrumb',
                providers: [
                    LocalizationService,
                    {
                        provide: L10N_PREFIX,
                        useValue: 'kendo.breadcrumb'
                    }
                ],
                template: `
        <ol
            #itemsContainer
            kendoBreadCrumbList
            class="k-breadcrumb-root-item-container"
            *ngIf="collapseMode === 'wrap'"
            [items]="firstItem$ | async"
            [itemTemplate]="itemTemplate?.templateRef"
            [collapseMode]="collapseMode"
            [separatorIcon]="separatorIcon"
            (itemClick)="itemClick.emit($event)"
        ></ol>
        <ol
            #itemsContainer
            kendoBreadCrumbList
            class="k-breadcrumb-container"
            [items]="itemsData$ | async"
            [itemTemplate]="itemTemplate?.templateRef"
            [collapseMode]="collapseMode"
            [separatorIcon]="separatorIcon"
            (itemClick)="itemClick.emit($event)"
            [ngClass]="{ 'k-flex-wrap': collapseMode === 'wrap', 'k-flex-none': collapseMode === 'none' }"
        ></ol>
        <kendo-resize-sensor [rateLimit]="1000" #resizeSensor></kendo-resize-sensor>
    `
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.NgZone }, { type: ɵngcc1.LocalizationService }]; }, { itemClick: [{
            type: Output
        }], hostClasses: [{
            type: HostBinding,
            args: ['class.k-widget']
        }, {
            type: HostBinding,
            args: ['class.k-breadcrumb']
        }], items: [{
            type: Input
        }], collapseMode: [{
            type: Input
        }], wrapMode: [{
            type: HostBinding,
            args: ['class.k-breadcrumb-wrap']
        }], getDir: [{
            type: HostBinding,
            args: ['attr.dir']
        }], separatorIcon: [{
            type: Input
        }], resizeSensor: [{
            type: ViewChild,
            args: ['resizeSensor', { static: true }]
        }], itemsContainers: [{
            type: ViewChildren,
            args: ['itemsContainer', { read: ElementRef }]
        }], listComponent: [{
            type: ViewChild,
            args: [BreadCrumbListComponent, { static: true }]
        }], itemTemplate: [{
            type: ContentChild,
            args: [BreadCrumbItemTemplateDirective, { static: true }]
        }] }); })();
export { BreadCrumbComponent };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYnJlYWRjcnVtYi5jb21wb25lbnQuanMiLCJzb3VyY2VzIjpbImJyZWFkY3J1bWIuY29tcG9uZW50LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztpS0FBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBcUNHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQUF3QjtBQUN4QiIsInNvdXJjZXNDb250ZW50IjpbIi8qKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4qIENvcHlyaWdodCDCqSAyMDIwIFByb2dyZXNzIFNvZnR3YXJlIENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuKiBMaWNlbnNlZCB1bmRlciBjb21tZXJjaWFsIGxpY2Vuc2UuIFNlZSBMSUNFTlNFLm1kIGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIG1vcmUgaW5mb3JtYXRpb25cbiotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbmltcG9ydCAqIGFzIHRzbGliXzEgZnJvbSBcInRzbGliXCI7XG5pbXBvcnQgeyBDb21wb25lbnQsIENvbnRlbnRDaGlsZCwgSW5wdXQsIE91dHB1dCwgRXZlbnRFbWl0dGVyLCBWaWV3Q2hpbGQsIEhvc3RCaW5kaW5nLCBFbGVtZW50UmVmLCBDaGFuZ2VEZXRlY3RvclJlZiwgTmdab25lLCBWaWV3Q2hpbGRyZW4sIFF1ZXJ5TGlzdCwgaXNEZXZNb2RlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBTdWJzY3JpcHRpb24sIFJlcGxheVN1YmplY3QsIG1lcmdlLCBTdWJqZWN0IH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBmaWx0ZXIsIG1hcCwgc2hhcmUsIHN0YXJ0V2l0aCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IFJlc2l6ZVNlbnNvckNvbXBvbmVudCwgaXNEb2N1bWVudEF2YWlsYWJsZSB9IGZyb20gJ0Bwcm9ncmVzcy9rZW5kby1hbmd1bGFyLWNvbW1vbic7XG5pbXBvcnQgeyB2YWxpZGF0ZVBhY2thZ2UgfSBmcm9tICdAcHJvZ3Jlc3Mva2VuZG8tbGljZW5zaW5nJztcbmltcG9ydCB7IHBhY2thZ2VNZXRhZGF0YSB9IGZyb20gJy4uL3BhY2thZ2UtbWV0YWRhdGEnO1xuaW1wb3J0IHsgTG9jYWxpemF0aW9uU2VydmljZSwgTDEwTl9QUkVGSVggfSBmcm9tICdAcHJvZ3Jlc3Mva2VuZG8tYW5ndWxhci1sMTBuJztcbmltcG9ydCB7IEJyZWFkQ3J1bWJJdGVtVGVtcGxhdGVEaXJlY3RpdmUgfSBmcm9tICcuL3RlbXBsYXRlLWRpcmVjdGl2ZXMvaXRlbS10ZW1wbGF0ZS5kaXJlY3RpdmUnO1xuaW1wb3J0IHsgb3V0ZXJXaWR0aCB9IGZyb20gJy4uL2NvbW1vbi91dGlsJztcbmltcG9ydCB7IEJyZWFkQ3J1bWJMaXN0Q29tcG9uZW50IH0gZnJvbSAnLi9saXN0LmNvbXBvbmVudCc7XG5pbXBvcnQgeyBjb2xsYXBzZWQsIGV4cGFuZGVkLCBjb2xsYXBzZUZpcnN0LCBleHBhbmRGaXJzdCB9IGZyb20gJy4vdXRpbCc7XG4vKipcbiAqIFJlcHJlc2VudHMgdGhlIFtLZW5kbyBVSSBCcmVhZGNydW1iIGNvbXBvbmVudCBmb3IgQW5ndWxhcl0oeyUgc2x1ZyBvdmVydmlld19icmVhZGNydW1iICV9KS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMtbm8tcnVuXG4gKiBfQENvbXBvbmVudCh7XG4gKiAgICAgIHNlbGVjdG9yOiAnbXktYXBwJyxcbiAqICAgICAgdGVtcGxhdGU6IGBcbiAqICAgICAgICAgIDxrZW5kby1icmVhZGNydW1iXG4gKiAgICAgICAgICAgICAgW2l0ZW1zXT1cIml0ZW1zXCJcbiAqICAgICAgICAgICAgICAoaXRlbUNsaWNrKT1cIm9uSXRlbUNsaWNrKCRldmVudClcIj5cbiAqICAgICAgICAgIDwva2VuZG8tYnJlYWRjcnVtYj5cbiAqICAgICAgYFxuICogfSlcbiAqIGNsYXNzIEFwcENvbXBvbmVudCB7XG4gKiAgICAgIHB1YmxpYyBpdGVtczogQnJlYWRDcnVtYkl0ZW1bXSA9IFtcbiAqICAgICAgICAgIHsgdGV4dDogJ0hvbWUnLCB0aXRsZTogJ0hvbWUnLCBpY29uOiAnaG9tZScgfSxcbiAqICAgICAgICAgIHsgdGV4dDogJ0tpZHMnLCB0aXRsZTogJ0tpZHMnIH0sXG4gKiAgICAgICAgICB7IHRleHQ6ICc4eS0xNnknLCB0aXRsZTogJzh5LTE2eScsIGRpc2FibGVkOiB0cnVlIH0sXG4gKiAgICAgICAgICB7IHRleHQ6ICdOZXcgY29sbGVjdGlvbicsIHRpdGxlOiAnTmV3IGNvbGxlY3Rpb24nIH0sXG4gKiAgICAgICAgICB7IHRleHQ6ICdKZWFucycsIHRpdGxlOiAnSmVhbnMnIH1cbiAqICAgICAgXTtcbiAqXG4gKiAgICAgIHB1YmxpYyBvbkl0ZW1DbGljayhpdGVtOiBCcmVhZENydW1iSXRlbSk6IHZvaWQge1xuICogICAgICAgICAgY29uc29sZS5sb2coaXRlbSk7XG4gKiAgICAgIH1cbiAqIH1cbiAqIGBgYFxuICovXG5sZXQgQnJlYWRDcnVtYkNvbXBvbmVudCA9IGNsYXNzIEJyZWFkQ3J1bWJDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKGVsLCBjZHIsIHpvbmUsIGxvY2FsaXphdGlvbikge1xuICAgICAgICB0aGlzLmVsID0gZWw7XG4gICAgICAgIHRoaXMuY2RyID0gY2RyO1xuICAgICAgICB0aGlzLnpvbmUgPSB6b25lO1xuICAgICAgICB0aGlzLmxvY2FsaXphdGlvbiA9IGxvY2FsaXphdGlvbjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpcmVzIHdoZW4gYSBCcmVhZGNydW1iIGl0ZW0gaXMgY2xpY2tlZC4gVGhlIGV2ZW50IHdpbGwgbm90IGJlIGZpcmVkIGJ5IGRpc2FibGVkIGl0ZW1zIGFuZCB0aGUgbGFzdCBpdGVtLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5pdGVtQ2xpY2sgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMuaG9zdENsYXNzZXMgPSB0cnVlO1xuICAgICAgICB0aGlzLl9pdGVtcyA9IFtdO1xuICAgICAgICB0aGlzLl9jb2xsYXBzZU1vZGUgPSAnYXV0byc7XG4gICAgICAgIHRoaXMudXBkYXRlSXRlbXMgPSBuZXcgUmVwbGF5U3ViamVjdCgpO1xuICAgICAgICB0aGlzLmFmdGVyVmlld0luaXQgPSBuZXcgU3ViamVjdCgpO1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMgPSBuZXcgU3Vic2NyaXB0aW9uKCk7XG4gICAgICAgIHRoaXMuZGlyZWN0aW9uID0gJ2x0cic7XG4gICAgICAgIHZhbGlkYXRlUGFja2FnZShwYWNrYWdlTWV0YWRhdGEpO1xuICAgICAgICBjb25zdCB1cGRhdGVJdGVtcyQgPSB0aGlzLnVwZGF0ZUl0ZW1zLmFzT2JzZXJ2YWJsZSgpLnBpcGUoc3RhcnRXaXRoKFtdKSk7XG4gICAgICAgIHRoaXMuZGlyZWN0aW9uID0gbG9jYWxpemF0aW9uLnJ0bCA/ICdydGwnIDogJ2x0cic7XG4gICAgICAgIHRoaXMuaXRlbXNEYXRhJCA9IHVwZGF0ZUl0ZW1zJC5waXBlKG1hcChpdGVtcyA9PiBpdGVtcy5maWx0ZXIoQm9vbGVhbikpLCBtYXAoaXRlbXMgPT4gaXRlbXMubWFwKChpdGVtLCBpbmRleCwgY29sbGVjdGlvbikgPT4gKHtcbiAgICAgICAgICAgIGNvbnRleHQ6IHtcbiAgICAgICAgICAgICAgICBjb2xsYXBzZWQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGlzTGFzdDogaW5kZXggPT09IGNvbGxlY3Rpb24ubGVuZ3RoIC0gMSxcbiAgICAgICAgICAgICAgICBpc0ZpcnN0OiBpbmRleCA9PT0gMFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRhdGE6IGl0ZW1cbiAgICAgICAgfSkpKSwgc2hhcmUoKSk7XG4gICAgICAgIHRoaXMuZmlyc3RJdGVtJCA9IHVwZGF0ZUl0ZW1zJC5waXBlKG1hcChpdGVtcyA9PiB7XG4gICAgICAgICAgICBpZiAoaXRlbXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQ6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xsYXBzZWQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzTGFzdDogaXRlbXMubGVuZ3RoID09PSAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzRmlyc3Q6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBpdGVtc1swXVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfSksIHNoYXJlKCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgY29sbGVjdGlvbiBvZiBpdGVtcyB0aGF0IHdpbGwgYmUgcmVuZGVyZWQgaW4gdGhlIEJyZWFkY3J1bWIuXG4gICAgICovXG4gICAgc2V0IGl0ZW1zKGl0ZW1zKSB7XG4gICAgICAgIHRoaXMuX2l0ZW1zID0gaXRlbXMgfHwgW107XG4gICAgICAgIHRoaXMudXBkYXRlSXRlbXMubmV4dCh0aGlzLl9pdGVtcyk7XG4gICAgfVxuICAgIGdldCBpdGVtcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2l0ZW1zO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTcGVjaWZpZXMgdGhlIGNvbGxhcHNlIG1vZGUgb2YgdGhlIEJyZWFkY3J1bWIgKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyBjb2xsYXBzZV9tb2Rlc19icmVhZGNydW1iICV9KSkuXG4gICAgICpcbiAgICAgKiBUaGUgcG9zc2libGUgdmFsdWVzIGFyZTpcbiAgICAgKiAtIGBhdXRvYCAoZGVmYXVsdCkmbWRhc2g7aXRlbXMgYXJlIGF1dG9tYXRpY2FsbHkgY29sbGFwc2VkIGJhc2VkIG9uIHRoZSB3aWR0aCBvZiB0aGUgQnJlYWRjcnVtYi5cbiAgICAgKiAtIGB3cmFwYCZtZGFzaDtpdGVtcyBhcmUgd3JhcHBlZCBvbiBtdWx0aXBsZSByb3dzLlxuICAgICAqIC0gYG5vbmVgJm1kYXNoO2FsbCBpdGVtcyBhcmUgZXhwYW5kZWQgb24gdGhlIHNhbWUgcm93LlxuICAgICAqXG4gICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24gYW5kIGV4YW1wbGUgcmVmZXIgdG8gdGhlIFtDb2xsYXBzZSBNb2Rlc10oeyUgc2x1ZyBjb2xsYXBzZV9tb2Rlc19icmVhZGNydW1iICV9KSBhcnRpY2xlLlxuICAgICAqL1xuICAgIHNldCBjb2xsYXBzZU1vZGUobW9kZSkge1xuICAgICAgICBpZiAoaXNEZXZNb2RlKCkgJiYgWydhdXRvJywgJ3dyYXAnLCAnbm9uZSddLmluZGV4T2YobW9kZSkgPCAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgY29sbGFwc2UgbW9kZS4gQWxsb3dlZCB2YWx1ZXMgYXJlIFwiYXV0b1wiLCBcIndyYXBcIiBvciBcIm5vbmVcIi4gXFxuRm9yIG1vcmUgZGV0YWlscyBzZWUgaHR0cHM6Ly93d3cudGVsZXJpay5jb20va2VuZG8tYW5ndWxhci11aS9jb21wb25lbnRzL25hdmlnYXRpb24vYXBpL0JyZWFkQ3J1bWJDb2xsYXBzZU1vZGUvJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fY29sbGFwc2VNb2RlID0gbW9kZSB8fCAnYXV0byc7XG4gICAgICAgIHRoaXMudXBkYXRlSXRlbXMubmV4dCh0aGlzLml0ZW1zKTtcbiAgICB9XG4gICAgZ2V0IGNvbGxhcHNlTW9kZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbGxhcHNlTW9kZTtcbiAgICB9XG4gICAgZ2V0IHdyYXBNb2RlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb2xsYXBzZU1vZGUgPT09ICd3cmFwJztcbiAgICB9XG4gICAgZ2V0IGdldERpcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGlyZWN0aW9uO1xuICAgIH1cbiAgICBuZ09uSW5pdCgpIHtcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zLmFkZCh0aGlzLmxvY2FsaXphdGlvbi5jaGFuZ2VzLnN1YnNjcmliZSgoeyBydGwgfSkgPT4gKHRoaXMuZGlyZWN0aW9uID0gcnRsID8gJ3J0bCcgOiAnbHRyJykpKTtcbiAgICB9XG4gICAgbmdBZnRlclZpZXdJbml0KCkge1xuICAgICAgICB0aGlzLmF0dGFjaFJlc2l6ZUhhbmRsZXIoKTtcbiAgICAgICAgdGhpcy5hZnRlclZpZXdJbml0Lm5leHQoKTtcbiAgICB9XG4gICAgbmdPbkRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy51bnN1YnNjcmliZSgpO1xuICAgIH1cbiAgICBoYW5kbGVSZXNpemUoKSB7XG4gICAgICAgIGNvbnN0IGF1dG9Db2xsYXBzZUNhbmRpZGF0ZXMgPSBbXG4gICAgICAgICAgICAuLi50aGlzLmxpc3RDb21wb25lbnQucmVuZGVyZWRJdGVtcy50b0FycmF5KCkuZmlsdGVyKHJpID0+ICFyaS5pdGVtLmNvbnRleHQuaXNGaXJzdCAmJiAhcmkuaXRlbS5jb250ZXh0LmlzTGFzdClcbiAgICAgICAgXTtcbiAgICAgICAgY29uc3QgY29tcG9uZW50V2lkdGggPSBvdXRlcldpZHRoKHRoaXMuZWwubmF0aXZlRWxlbWVudCk7XG4gICAgICAgIGNvbnN0IGl0ZW1zQ29udGFpbmVyV2lkdGggPSBNYXRoLmZsb29yKHRoaXMuaXRlbXNDb250YWluZXJzXG4gICAgICAgICAgICAudG9BcnJheSgpXG4gICAgICAgICAgICAubWFwKGVsID0+IG91dGVyV2lkdGgoZWwubmF0aXZlRWxlbWVudCkpXG4gICAgICAgICAgICAucmVkdWNlKChhY2MsIGN1cnIpID0+IGFjYyArIGN1cnIsIDApKTtcbiAgICAgICAgY29uc3QgbmV4dEV4cGFuZFdpZHRoID0gKFsuLi5hdXRvQ29sbGFwc2VDYW5kaWRhdGVzXS5yZXZlcnNlKCkuZmluZChjb2xsYXBzZWQpIHx8IHsgd2lkdGg6IDAgfSkud2lkdGg7XG4gICAgICAgIC8vIC8vIHNocmlua1xuICAgICAgICBpZiAoY29tcG9uZW50V2lkdGggPD0gaXRlbXNDb250YWluZXJXaWR0aCAmJiBhdXRvQ29sbGFwc2VDYW5kaWRhdGVzLmZpbmQoZXhwYW5kZWQpKSB7XG4gICAgICAgICAgICBjb2xsYXBzZUZpcnN0KGF1dG9Db2xsYXBzZUNhbmRpZGF0ZXMpO1xuICAgICAgICAgICAgLy8gbmVlZGVkIGJ5IHJlc2l6ZSBzZW5zb3JcbiAgICAgICAgICAgIHRoaXMuY2RyLmRldGVjdENoYW5nZXMoKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmhhbmRsZVJlc2l6ZSgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGV4cGFuZFxuICAgICAgICBpZiAoY29tcG9uZW50V2lkdGggPiBpdGVtc0NvbnRhaW5lcldpZHRoICsgbmV4dEV4cGFuZFdpZHRoICYmIGF1dG9Db2xsYXBzZUNhbmRpZGF0ZXMuZmluZChjb2xsYXBzZWQpKSB7XG4gICAgICAgICAgICBleHBhbmRGaXJzdChbLi4uYXV0b0NvbGxhcHNlQ2FuZGlkYXRlc10ucmV2ZXJzZSgpKTtcbiAgICAgICAgICAgIC8vIG5lZWRlZCBieSByZXNpemUgc2Vuc29yXG4gICAgICAgICAgICB0aGlzLmNkci5kZXRlY3RDaGFuZ2VzKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5oYW5kbGVSZXNpemUoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzaG91bGRSZXNpemUoKSB7XG4gICAgICAgIHJldHVybiBpc0RvY3VtZW50QXZhaWxhYmxlKCkgJiYgdGhpcy5jb2xsYXBzZU1vZGUgPT09ICdhdXRvJztcbiAgICB9XG4gICAgYXR0YWNoUmVzaXplSGFuZGxlcigpIHtcbiAgICAgICAgLy8gcmVzaXplIHdoZW46XG4gICAgICAgIC8vIHRoZSBjb21wb25lbnQgaXMgaW5pdGlhbGl6ZWRcbiAgICAgICAgLy8gdGhlIGNvbnRhaW5lciBpcyByZXNpemVkXG4gICAgICAgIC8vIGl0ZW1zIGFyZSBhZGRlZC9yZW1vdmVkXG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5hZGQobWVyZ2UodGhpcy5yZXNpemVTZW5zb3IucmVzaXplLCB0aGlzLml0ZW1zRGF0YSQsIHRoaXMuYWZ0ZXJWaWV3SW5pdC5hc09ic2VydmFibGUoKSlcbiAgICAgICAgICAgIC5waXBlKGZpbHRlcigoKSA9PiB0aGlzLnNob3VsZFJlc2l6ZSgpKSlcbiAgICAgICAgICAgIC5zdWJzY3JpYmUoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy56b25lLnJ1bk91dHNpZGVBbmd1bGFyKCgpID0+IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuem9uZS5ydW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5saXN0Q29tcG9uZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZVJlc2l6ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXNpemVTZW5zb3IuYWNjZXB0U2l6ZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH0pKTtcbiAgICB9XG59O1xudHNsaWJfMS5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIHRzbGliXzEuX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEFycmF5KSxcbiAgICB0c2xpYl8xLl9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbQXJyYXldKVxuXSwgQnJlYWRDcnVtYkNvbXBvbmVudC5wcm90b3R5cGUsIFwiaXRlbXNcIiwgbnVsbCk7XG50c2xpYl8xLl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgdHNsaWJfMS5fX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgQnJlYWRDcnVtYkNvbXBvbmVudC5wcm90b3R5cGUsIFwic2VwYXJhdG9ySWNvblwiLCB2b2lkIDApO1xudHNsaWJfMS5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIHRzbGliXzEuX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZyksXG4gICAgdHNsaWJfMS5fX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW1N0cmluZ10pXG5dLCBCcmVhZENydW1iQ29tcG9uZW50LnByb3RvdHlwZSwgXCJjb2xsYXBzZU1vZGVcIiwgbnVsbCk7XG50c2xpYl8xLl9fZGVjb3JhdGUoW1xuICAgIE91dHB1dCgpLFxuICAgIHRzbGliXzEuX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEV2ZW50RW1pdHRlcilcbl0sIEJyZWFkQ3J1bWJDb21wb25lbnQucHJvdG90eXBlLCBcIml0ZW1DbGlja1wiLCB2b2lkIDApO1xudHNsaWJfMS5fX2RlY29yYXRlKFtcbiAgICBWaWV3Q2hpbGQoJ3Jlc2l6ZVNlbnNvcicsIHsgc3RhdGljOiB0cnVlIH0pLFxuICAgIHRzbGliXzEuX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFJlc2l6ZVNlbnNvckNvbXBvbmVudClcbl0sIEJyZWFkQ3J1bWJDb21wb25lbnQucHJvdG90eXBlLCBcInJlc2l6ZVNlbnNvclwiLCB2b2lkIDApO1xudHNsaWJfMS5fX2RlY29yYXRlKFtcbiAgICBWaWV3Q2hpbGRyZW4oJ2l0ZW1zQ29udGFpbmVyJywgeyByZWFkOiBFbGVtZW50UmVmIH0pLFxuICAgIHRzbGliXzEuX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFF1ZXJ5TGlzdClcbl0sIEJyZWFkQ3J1bWJDb21wb25lbnQucHJvdG90eXBlLCBcIml0ZW1zQ29udGFpbmVyc1wiLCB2b2lkIDApO1xudHNsaWJfMS5fX2RlY29yYXRlKFtcbiAgICBWaWV3Q2hpbGQoQnJlYWRDcnVtYkxpc3RDb21wb25lbnQsIHsgc3RhdGljOiB0cnVlIH0pLFxuICAgIHRzbGliXzEuX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJyZWFkQ3J1bWJMaXN0Q29tcG9uZW50KVxuXSwgQnJlYWRDcnVtYkNvbXBvbmVudC5wcm90b3R5cGUsIFwibGlzdENvbXBvbmVudFwiLCB2b2lkIDApO1xudHNsaWJfMS5fX2RlY29yYXRlKFtcbiAgICBDb250ZW50Q2hpbGQoQnJlYWRDcnVtYkl0ZW1UZW1wbGF0ZURpcmVjdGl2ZSwgeyBzdGF0aWM6IHRydWUgfSksXG4gICAgdHNsaWJfMS5fX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQnJlYWRDcnVtYkl0ZW1UZW1wbGF0ZURpcmVjdGl2ZSlcbl0sIEJyZWFkQ3J1bWJDb21wb25lbnQucHJvdG90eXBlLCBcIml0ZW1UZW1wbGF0ZVwiLCB2b2lkIDApO1xudHNsaWJfMS5fX2RlY29yYXRlKFtcbiAgICBIb3N0QmluZGluZygnY2xhc3Muay13aWRnZXQnKSxcbiAgICBIb3N0QmluZGluZygnY2xhc3Muay1icmVhZGNydW1iJyksXG4gICAgdHNsaWJfMS5fX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIEJyZWFkQ3J1bWJDb21wb25lbnQucHJvdG90eXBlLCBcImhvc3RDbGFzc2VzXCIsIHZvaWQgMCk7XG50c2xpYl8xLl9fZGVjb3JhdGUoW1xuICAgIEhvc3RCaW5kaW5nKCdjbGFzcy5rLWJyZWFkY3J1bWItd3JhcCcpLFxuICAgIHRzbGliXzEuX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pLFxuICAgIHRzbGliXzEuX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKVxuXSwgQnJlYWRDcnVtYkNvbXBvbmVudC5wcm90b3R5cGUsIFwid3JhcE1vZGVcIiwgbnVsbCk7XG50c2xpYl8xLl9fZGVjb3JhdGUoW1xuICAgIEhvc3RCaW5kaW5nKCdhdHRyLmRpcicpLFxuICAgIHRzbGliXzEuX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZyksXG4gICAgdHNsaWJfMS5fX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pXG5dLCBCcmVhZENydW1iQ29tcG9uZW50LnByb3RvdHlwZSwgXCJnZXREaXJcIiwgbnVsbCk7XG5CcmVhZENydW1iQ29tcG9uZW50ID0gdHNsaWJfMS5fX2RlY29yYXRlKFtcbiAgICBDb21wb25lbnQoe1xuICAgICAgICBleHBvcnRBczogJ2tlbmRvQnJlYWRDcnVtYicsXG4gICAgICAgIHNlbGVjdG9yOiAna2VuZG8tYnJlYWRjcnVtYicsXG4gICAgICAgIHByb3ZpZGVyczogW1xuICAgICAgICAgICAgTG9jYWxpemF0aW9uU2VydmljZSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBwcm92aWRlOiBMMTBOX1BSRUZJWCxcbiAgICAgICAgICAgICAgICB1c2VWYWx1ZTogJ2tlbmRvLmJyZWFkY3J1bWInXG4gICAgICAgICAgICB9XG4gICAgICAgIF0sXG4gICAgICAgIHRlbXBsYXRlOiBgXG4gICAgICAgIDxvbFxuICAgICAgICAgICAgI2l0ZW1zQ29udGFpbmVyXG4gICAgICAgICAgICBrZW5kb0JyZWFkQ3J1bWJMaXN0XG4gICAgICAgICAgICBjbGFzcz1cImstYnJlYWRjcnVtYi1yb290LWl0ZW0tY29udGFpbmVyXCJcbiAgICAgICAgICAgICpuZ0lmPVwiY29sbGFwc2VNb2RlID09PSAnd3JhcCdcIlxuICAgICAgICAgICAgW2l0ZW1zXT1cImZpcnN0SXRlbSQgfCBhc3luY1wiXG4gICAgICAgICAgICBbaXRlbVRlbXBsYXRlXT1cIml0ZW1UZW1wbGF0ZT8udGVtcGxhdGVSZWZcIlxuICAgICAgICAgICAgW2NvbGxhcHNlTW9kZV09XCJjb2xsYXBzZU1vZGVcIlxuICAgICAgICAgICAgW3NlcGFyYXRvckljb25dPVwic2VwYXJhdG9ySWNvblwiXG4gICAgICAgICAgICAoaXRlbUNsaWNrKT1cIml0ZW1DbGljay5lbWl0KCRldmVudClcIlxuICAgICAgICA+PC9vbD5cbiAgICAgICAgPG9sXG4gICAgICAgICAgICAjaXRlbXNDb250YWluZXJcbiAgICAgICAgICAgIGtlbmRvQnJlYWRDcnVtYkxpc3RcbiAgICAgICAgICAgIGNsYXNzPVwiay1icmVhZGNydW1iLWNvbnRhaW5lclwiXG4gICAgICAgICAgICBbaXRlbXNdPVwiaXRlbXNEYXRhJCB8IGFzeW5jXCJcbiAgICAgICAgICAgIFtpdGVtVGVtcGxhdGVdPVwiaXRlbVRlbXBsYXRlPy50ZW1wbGF0ZVJlZlwiXG4gICAgICAgICAgICBbY29sbGFwc2VNb2RlXT1cImNvbGxhcHNlTW9kZVwiXG4gICAgICAgICAgICBbc2VwYXJhdG9ySWNvbl09XCJzZXBhcmF0b3JJY29uXCJcbiAgICAgICAgICAgIChpdGVtQ2xpY2spPVwiaXRlbUNsaWNrLmVtaXQoJGV2ZW50KVwiXG4gICAgICAgICAgICBbbmdDbGFzc109XCJ7ICdrLWZsZXgtd3JhcCc6IGNvbGxhcHNlTW9kZSA9PT0gJ3dyYXAnLCAnay1mbGV4LW5vbmUnOiBjb2xsYXBzZU1vZGUgPT09ICdub25lJyB9XCJcbiAgICAgICAgPjwvb2w+XG4gICAgICAgIDxrZW5kby1yZXNpemUtc2Vuc29yIFtyYXRlTGltaXRdPVwiMTAwMFwiICNyZXNpemVTZW5zb3I+PC9rZW5kby1yZXNpemUtc2Vuc29yPlxuICAgIGBcbiAgICB9KSxcbiAgICB0c2xpYl8xLl9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbRWxlbWVudFJlZixcbiAgICAgICAgQ2hhbmdlRGV0ZWN0b3JSZWYsXG4gICAgICAgIE5nWm9uZSxcbiAgICAgICAgTG9jYWxpemF0aW9uU2VydmljZV0pXG5dLCBCcmVhZENydW1iQ29tcG9uZW50KTtcbmV4cG9ydCB7IEJyZWFkQ3J1bWJDb21wb25lbnQgfTtcbiJdfQ==