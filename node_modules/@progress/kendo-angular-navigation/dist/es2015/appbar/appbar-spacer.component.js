/**-----------------------------------------------------------------------------------------
* Copyright © 2020 Progress Software Corporation. All rights reserved.
* Licensed under commercial license. See LICENSE.md in the project root for more information
*-------------------------------------------------------------------------------------------*/
import * as tslib_1 from "tslib";
import { Component, HostBinding, Input, Renderer2, ElementRef } from '@angular/core';
import { isPresent } from '../common/util';
/**
 * Represents the [Kendo UI AppBarSpacer component for Angular]({% slug contentarrangement_appbar %}#toc-spacings).
 * Used to give additional white space between the AppBar sections and provides a way for customizing its width.
 *
 * @example
 *
 * ```ts-no-run
 *  * _@Component({
 *    selector: 'my-app',
 *    template: `
 *        <kendo-appbar>
 *            <kendo-appbar-section>
 *                 <button class="k-button k-button-clear">
 *                     <kendo-icon [name]="'menu'"></kendo-icon>
 *                 </button>
 *            </kendo-appbar-section>
 *
 *            <kendo-appbar-spacer></kendo-appbar-spacer>
 *
 *            <kendo-appbar-section>
 *                <h2>Page Title</h2>
 *            </kendo-appbar-section>
 *        </kendo-appbar>
 *    `
 * })
 * class AppComponent {}
 * ```
 */
import * as ɵngcc0 from '@angular/core';
let AppBarSpacerComponent = class AppBarSpacerComponent {
    constructor(renderer, element) {
        this.renderer = renderer;
        this.element = element;
        this.hostClass = true;
    }
    get sizedClass() {
        return isPresent(this.width);
    }
    ngAfterViewInit() {
        if (isPresent(this.width)) {
            const element = this.element.nativeElement;
            this.renderer.setStyle(element, 'flexBasis', this.width);
        }
    }
};
AppBarSpacerComponent.ɵfac = function AppBarSpacerComponent_Factory(t) { return new (t || AppBarSpacerComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
AppBarSpacerComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: AppBarSpacerComponent, selectors: [["kendo-appbar-spacer"]], hostVars: 4, hostBindings: function AppBarSpacerComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("k-appbar-spacer", ctx.hostClass)("k-appbar-spacer-sized", ctx.sizedClass);
    } }, inputs: { width: "width" }, decls: 0, vars: 0, template: function AppBarSpacerComponent_Template(rf, ctx) { }, encapsulation: 2 });
tslib_1.__decorate([
    HostBinding('class.k-appbar-spacer'),
    tslib_1.__metadata("design:type", Boolean)
], AppBarSpacerComponent.prototype, "hostClass", void 0);
tslib_1.__decorate([
    HostBinding('class.k-appbar-spacer-sized'),
    tslib_1.__metadata("design:type", Boolean),
    tslib_1.__metadata("design:paramtypes", [])
], AppBarSpacerComponent.prototype, "sizedClass", null);
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", String)
], AppBarSpacerComponent.prototype, "width", void 0);
AppBarSpacerComponent = tslib_1.__decorate([ tslib_1.__metadata("design:paramtypes", [Renderer2, ElementRef])
], AppBarSpacerComponent);
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(AppBarSpacerComponent, [{
        type: Component,
        args: [{
                selector: 'kendo-appbar-spacer',
                template: ``
            }]
    }], function () { return [{ type: ɵngcc0.Renderer2 }, { type: ɵngcc0.ElementRef }]; }, { hostClass: [{
            type: HostBinding,
            args: ['class.k-appbar-spacer']
        }], sizedClass: [{
            type: HostBinding,
            args: ['class.k-appbar-spacer-sized']
        }], width: [{
            type: Input
        }] }); })();
export { AppBarSpacerComponent };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXBwYmFyLXNwYWNlci5jb21wb25lbnQuanMiLCJzb3VyY2VzIjpbImFwcGJhci1zcGFjZXIuY29tcG9uZW50LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7NElBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUtHO0FBQ0g7Ozs7Ozs7Ozs7Ozs7OztvQkFBMEI7QUFDMUIiLCJzb3VyY2VzQ29udGVudCI6WyIvKiotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuKiBDb3B5cmlnaHQgwqkgMjAyMCBQcm9ncmVzcyBTb2Z0d2FyZSBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiogTGljZW5zZWQgdW5kZXIgY29tbWVyY2lhbCBsaWNlbnNlLiBTZWUgTElDRU5TRS5tZCBpbiB0aGUgcHJvamVjdCByb290IGZvciBtb3JlIGluZm9ybWF0aW9uXG4qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5pbXBvcnQgKiBhcyB0c2xpYl8xIGZyb20gXCJ0c2xpYlwiO1xuaW1wb3J0IHsgQ29tcG9uZW50LCBIb3N0QmluZGluZywgSW5wdXQsIFJlbmRlcmVyMiwgRWxlbWVudFJlZiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgaXNQcmVzZW50IH0gZnJvbSAnLi4vY29tbW9uL3V0aWwnO1xuLyoqXG4gKiBSZXByZXNlbnRzIHRoZSBbS2VuZG8gVUkgQXBwQmFyU3BhY2VyIGNvbXBvbmVudCBmb3IgQW5ndWxhcl0oeyUgc2x1ZyBjb250ZW50YXJyYW5nZW1lbnRfYXBwYmFyICV9I3RvYy1zcGFjaW5ncykuXG4gKiBVc2VkIHRvIGdpdmUgYWRkaXRpb25hbCB3aGl0ZSBzcGFjZSBiZXR3ZWVuIHRoZSBBcHBCYXIgc2VjdGlvbnMgYW5kIHByb3ZpZGVzIGEgd2F5IGZvciBjdXN0b21pemluZyBpdHMgd2lkdGguXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiBgYGB0cy1uby1ydW5cbiAqICAqIF9AQ29tcG9uZW50KHtcbiAqICAgIHNlbGVjdG9yOiAnbXktYXBwJyxcbiAqICAgIHRlbXBsYXRlOiBgXG4gKiAgICAgICAgPGtlbmRvLWFwcGJhcj5cbiAqICAgICAgICAgICAgPGtlbmRvLWFwcGJhci1zZWN0aW9uPlxuICogICAgICAgICAgICAgICAgIDxidXR0b24gY2xhc3M9XCJrLWJ1dHRvbiBrLWJ1dHRvbi1jbGVhclwiPlxuICogICAgICAgICAgICAgICAgICAgICA8a2VuZG8taWNvbiBbbmFtZV09XCInbWVudSdcIj48L2tlbmRvLWljb24+XG4gKiAgICAgICAgICAgICAgICAgPC9idXR0b24+XG4gKiAgICAgICAgICAgIDwva2VuZG8tYXBwYmFyLXNlY3Rpb24+XG4gKlxuICogICAgICAgICAgICA8a2VuZG8tYXBwYmFyLXNwYWNlcj48L2tlbmRvLWFwcGJhci1zcGFjZXI+XG4gKlxuICogICAgICAgICAgICA8a2VuZG8tYXBwYmFyLXNlY3Rpb24+XG4gKiAgICAgICAgICAgICAgICA8aDI+UGFnZSBUaXRsZTwvaDI+XG4gKiAgICAgICAgICAgIDwva2VuZG8tYXBwYmFyLXNlY3Rpb24+XG4gKiAgICAgICAgPC9rZW5kby1hcHBiYXI+XG4gKiAgICBgXG4gKiB9KVxuICogY2xhc3MgQXBwQ29tcG9uZW50IHt9XG4gKiBgYGBcbiAqL1xubGV0IEFwcEJhclNwYWNlckNvbXBvbmVudCA9IGNsYXNzIEFwcEJhclNwYWNlckNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IocmVuZGVyZXIsIGVsZW1lbnQpIHtcbiAgICAgICAgdGhpcy5yZW5kZXJlciA9IHJlbmRlcmVyO1xuICAgICAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgICB0aGlzLmhvc3RDbGFzcyA9IHRydWU7XG4gICAgfVxuICAgIGdldCBzaXplZENsYXNzKCkge1xuICAgICAgICByZXR1cm4gaXNQcmVzZW50KHRoaXMud2lkdGgpO1xuICAgIH1cbiAgICBuZ0FmdGVyVmlld0luaXQoKSB7XG4gICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy53aWR0aCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudDtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuc2V0U3R5bGUoZWxlbWVudCwgJ2ZsZXhCYXNpcycsIHRoaXMud2lkdGgpO1xuICAgICAgICB9XG4gICAgfVxufTtcbnRzbGliXzEuX19kZWNvcmF0ZShbXG4gICAgSG9zdEJpbmRpbmcoJ2NsYXNzLmstYXBwYmFyLXNwYWNlcicpLFxuICAgIHRzbGliXzEuX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBBcHBCYXJTcGFjZXJDb21wb25lbnQucHJvdG90eXBlLCBcImhvc3RDbGFzc1wiLCB2b2lkIDApO1xudHNsaWJfMS5fX2RlY29yYXRlKFtcbiAgICBIb3N0QmluZGluZygnY2xhc3Muay1hcHBiYXItc3BhY2VyLXNpemVkJyksXG4gICAgdHNsaWJfMS5fX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbiksXG4gICAgdHNsaWJfMS5fX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pXG5dLCBBcHBCYXJTcGFjZXJDb21wb25lbnQucHJvdG90eXBlLCBcInNpemVkQ2xhc3NcIiwgbnVsbCk7XG50c2xpYl8xLl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgdHNsaWJfMS5fX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgQXBwQmFyU3BhY2VyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ3aWR0aFwiLCB2b2lkIDApO1xuQXBwQmFyU3BhY2VyQ29tcG9uZW50ID0gdHNsaWJfMS5fX2RlY29yYXRlKFtcbiAgICBDb21wb25lbnQoe1xuICAgICAgICBzZWxlY3RvcjogJ2tlbmRvLWFwcGJhci1zcGFjZXInLFxuICAgICAgICB0ZW1wbGF0ZTogYGBcbiAgICB9KSxcbiAgICB0c2xpYl8xLl9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbUmVuZGVyZXIyLCBFbGVtZW50UmVmXSlcbl0sIEFwcEJhclNwYWNlckNvbXBvbmVudCk7XG5leHBvcnQgeyBBcHBCYXJTcGFjZXJDb21wb25lbnQgfTtcbiJdfQ==